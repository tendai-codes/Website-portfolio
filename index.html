<!DOCTYPE HTML>
<!--
	Dimension by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Tendai N Sibanda | Data Science Portfolio</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>

		<!-- Highlight.js core CSS (choose your theme) -->
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
	
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<div class="logo">
							<span class="icon fa-gem"></span>
						</div>
						<div class="content">
							<div class="inner">
								<h1>Tendai N Sibanda <br> Data Science Portfolio</h1>
								<p>Making sense of complexity through data. Leveraging AI to empower people and decisions.</p>
							</div>
						</div>
						<nav>
							<ul>
								<li><a href="#intro">Intro</a></li>
								<li><a href="#projects">Projects</a></li>
								<li><a href="#about">About Me</a></li>
								<li><a href="#contact">Contact</a></li>
								<!--<li><a href="#elements">Elements</a></li>-->
							</ul>
						</nav>
					</header>

				<!-- Main -->
					<div id="main">

						<!-- Intro -->
							<article id="intro">
								<h2 class="major">Intro</h2>
								<span class="image main"><img src="images/roadmap.png" alt="" /></span>
								<p>This portfolio captures my journey from data analytics to machine learning. I began with projects in R and soon transitioned to Python, where I discovered the world of AI. Along the way, I‚Äôve learned to build models catering to supervised and unsupervised learning. I‚Äôm currently getting more familiar with deep learning‚Äîspecifically computer vision and retrieval-augmented generation. Check out some of my work <a href="#projects"> here</a>.</p>
								
							</article>

						<!-- Projects -->
							<article id="projects">
								<h2 class="major">Projects</h2>
								<span class="image main"><img src="images/datascience.png" alt="" /></span>
								<p>This section showcases hands-on projects where I apply Python and R to solve real-world problems. From data cleaning to model evaluation, each project includes a clear data pipeline, code snippets, and key takeaways. You‚Äôll also find notes on the challenges I faced and how I overcame them, offering insight into my problem-solving approach.</p>
							
								<h2 class="major">Project Types</h2>

								<div id="project-filters">
									
									<button data-tag="R" class="filter-button">R</button>
									<button data-tag="Python" class="filter-button">Python</button>
									<button data-tag="Data Analysis" class="filter-button">Data Analysis</button>
									<button data-tag="Machine Learning" class="filter-button">Machine Learning</button>
									<button data-tag="PyTorch" class="filter-button">PyTorch</button>
									<button data-tag="TensorFlow" class="filter-button">TensorFlow</button>
									<button data-tag="Deep Learning" class="filter-button">Deep Learning</button>
							
									<button data-tag="all" class="filter-button active">All</button>
									
                				</div>

								<div id="projects-container">

									<section class="project-item" data-tags="R,Data Analysis">
										<h3>üìΩÔ∏è <strong>Box Office Data Analysis </strong></h3>
										<p>
											This project explored publicly available data on top-grossing US films to identify patterns across genres, studios, and release schedules. I used <strong>R</strong> and <strong>ggplot2</strong> for data exploration and visualisation.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>R</strong> for data manipulation and visualisation</li>
											<li><strong>ggplot2</strong> for creating custom, layered visual insights</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Import & inspect data:</strong> Used <code>read.csv()</code>, <code>summary()</code>, and <code>str()</code></li>
											<li><strong>Initial exploration:</strong> Identified no Monday releases using a bar plot of <code>Day.of.Week</code></li>
											<li><strong>Filtering for significance:</strong> Narrowed to key genres and major studios</li>
											<li><strong>Visualisation:</strong> Created jitter + box plots comparing domestic gross</li>
											<li><strong>Aesthetics:</strong> Tuned themes for clarity and presentation</li>
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-r"># No movies are ever released on a Monday. (Figure 1)
										ggplot(data=mov, aes(x=Day.of.Week)) + geom_bar()

										# Filter dataset for desired genres:
										filt <- (mov$Genre == "action") | (mov$Genre == "adventure") | 
												(mov$Genre == "animation") | (mov$Genre == "comedy") | (mov$Genre == "drama")

										# Filter dataset for desired studios:
										filt2 <- (mov$Studio == "Buena Vista Studios") | (mov$Studio == "WB") | 
												(mov$Studio == "Fox") | (mov$Studio == "Universal") | 
												(mov$Studio == "Sony") | (mov$Studio == "Paramount Pictures")

										# Apply filters
										mov2 <- mov[filt & filt2,]

										# Prepare the plot's data and aes layers (Figure 2)
										p <- ggplot(data=mov2, aes(x=Genre, y=Gross...US))

										q <- p +
										geom_jitter(aes(size=Budget...mill., colour=Studio)) +
										geom_boxplot(alpha = 0.7, outlier.colour = NA)

										# Non-data info
										q +
										xlab("Genre") + 
										ylab("Gross % US") + 
										ggtitle("Domestic Gross % by Genre")

										# Theme
										q <- q +
										theme(
											text = element_text(family="Times New Roman"),
											axis.title.x = element_text(colour="Blue", size=30),
											axis.title.y = element_text(colour="Blue", size=30),
											axis.text.x = element_text(size=20),
											axis.text.y = element_text(size=20),
											plot.title = element_text(colour="Black", size=40),
											legend.title = element_text(size=20),
											legend.text = element_text(size=12)
										)
										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/box_office.png" 
													alt="Figure 1: No releases on Mondays"
													class="gallery-trigger"
													data-gallery="box-analysis"
													data-caption="Figure 1: No releases on Mondays">
												<figcaption><strong>Figure 1</strong> No releases on Mondays</figcaption>
											</figure>

											<figure>
												<img src="images/box_genre.png" 
													alt="Figure 2: Domestic gross by genre"
													class="gallery-trigger"
													data-gallery="box-analysis"
													data-caption="Figure 2: Domestic gross by genre">
												<figcaption><strong>Figure 2</strong> Domestic gross by genre</figcaption>
											</figure>
										</div>

										

										<h4>üåü <strong>Key Insights:</strong></h4>
										<p>
											Profitable genres are concentrated among a few studios. Monday releases are avoided ‚Äî possibly a scheduling strategy.
										</p>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											Overlapping outliers and jitter points in ggplot2 caused clutter. I resolved this with <code>outlier.colour = NA</code> and <code>alpha</code> blending.
										</p>
										<p><a href="https://github.com/tendai-codes/Data-Analysis" class="github-button" target="_blank">View on GitHub</a></p>
										</p>
									</section>

									<section class="project-item" data-tags="R,Data Analysis">
										<h3>üìΩÔ∏è <strong>Financial Statement Analysis </strong></h3>
										<p>
											This project analysed five years of company financial data (2018‚Äì2022), including Balance Sheet, Income Statement, and Cash Flow Statement. I used Python and pandas to calculate key financial ratios, identify operational trends, and visualise multi-year performance.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>R</strong> for data manipulation and analysis</li>
											<li><strong>Pandas</strong> for computations</li>
											<li><strong>Matplotlib</strong> for plotting financial visualisations</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Load & inspect data:</strong> Imported multi-statement CSV into pandas. Extracted relevant sections for Balance Sheet, Income Statement, and Cash Flow Statement using <code>loc[]</code>. </li>
											<li><strong>Trend Analysis:</strong> Plotted major components (e.g. assets, equity) using <code>.plot()</code> to visualise financial stability over time. </li>
											<li><strong>Ratio Calculations:</strong> Computed solvency and profitability ratios: Return on Equity (ROE), Return on Assets (ROA), Debt-to-Equity. Built <code>DataFrame</code> to summarise and visualise using grouped bar plots.</li>
											<li><strong>Custom Metrics:</strong> Created Operating Cash Flow to Total Debt ratio from cash flow and balance sheet sections to assess short-term liquidity strength.</li>
											
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-r"># Load required library for visualizations
										library(ggplot2)
										library(tidyverse)
										# Data
										revenue <- c(14574.49, 7606.46, 8611.41, 9175.41, 8058.65, 8105.44, 11496.28, 9766.09, 10305.32, 14379.96, 10713.97, 15433.50)
										expenses <- c(12051.82, 5695.07, 12319.20, 12089.72, 8658.57, 840.20, 3285.73, 5821.12, 6976.93, 16618.61, 10054.37, 3803.96)

										# Calculate Profit As The Differences Between Revenue And Expenses
										profit <- revenue - expenses
										profit

										# Calculate Tax As 30% Of Profit And Round To 2 Decimal Points
										tax <- round(0.30 * profit, 2)
										tax

										# Calculate Profit Remaining After Tax Is Deducted
										profit.after.tax <- profit - tax
										profit.after.tax

										#Visualize Profit after tax
										# Create a data frame for visualization
										data <- data.frame(
										Month = 1:12,
										Profit_After_Tax = profit.after.tax)

										# Create the bar chart using ggplot2 (Figure 1)
										ggplot(data, aes(x = factor(Month), y = Profit_After_Tax)) +
										geom_bar(stat = "identity", fill = "steelblue") +
										labs(title = "Monthly Profit After Tax", x = "Month", y = "Profit After Tax") +
										theme_minimal()

										# Calculate The Profit Margin As Profit After Tax Over Revenue
										profit.margin <- round(profit.after.tax / revenue, 2) * 100
										profit.margin

										# Visualize Profit Margin
										# Create a data frame for visualization
										data <- data.frame(
										Month = 1:12,
										Profit_margin = profit.margin)

										# Create the bar chart using ggplot2 (Figure 2)
										ggplot(data, aes(x = factor(Month), y = profit.margin)) +
										geom_bar(stat = "identity", fill = "orange") +
										labs(title = "Monthly Profit Margin (%)", x = "Month", y = "Profit Margin (%)") +
										theme_minimal()

										# Calculate The Mean Profit After Tax For The 12 Months
										mean_pat <- mean(profit.after.tax)
										mean_pat

										# Find The Months With Above-Mean Profit After Tax
										good.months <- profit.after.tax > mean_pat
										good.months

										# Bad Months Are The Opposite Of Good Months
										bad.months <- !good.months
										bad.months

										# The Best Month Is The Month With The Highest Profit After Tax
										best.month <- profit.after.tax == max(profit.after.tax)
										best.month

										# The Worst Month Is The Month With The Lowest Profit After Tax
										worst.month <- profit.after.tax == min(profit.after.tax)
										worst.month
										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/Financial_statement_b.png" 
													alt="Figure 1: Profit After Tax"
													class="gallery-trigger"
													data-gallery="finance-state"
													data-caption="Figure 1: Profit After Tax">
												<figcaption><strong>Figure 1</strong> Profit After Tax</figcaption>
											</figure>

											<figure>
												<img src="images/Financial_statement_O.png" 
													alt="Figure 2: Profit Margin"
													class="gallery-trigger"
													data-gallery="finance-state"
													data-caption="Figure 2: Profit Margin">
												<figcaption><strong>Figure 2</strong> Profit Margin</figcaption>
											</figure>
										</div>


										<h4>üåü <strong>Key Insights:</strong></h4>
										<p>
											The company showed stable asset growth and rising equity, but the Debt-to-Equity ratio increased post-2020, signalling higher leverage risk.
											Operating cash flow was consistently positive, suggesting sufficient liquidity to meet short-term obligations ‚Äî a green flag for operational health.
										</p>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											Initially, aligning the financial statements by year was inconsistent due to mixed string/index formats across categories. I overcame this by explicitly extracting year-based columns and standardising label references. This made ratio computations and cross-statement comparisons reliable and reproducible.
										</p>
										<p><a href="https://github.com/tendai-codes/Data-Analysis" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,Data Analysis">
										<h3>üìΩÔ∏è <strong>Global Population Trends Exploration </strong></h3>
										<p>
											This project used World Bank development indicators to explore trends in population growth, urbanisation, and fertility rates across continents and income groups. The objective was to uncover insights about global development patterns over time using Python.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for data handling and exploration</li>
											<li><strong>Pandas</strong> for data manipulation</li>
											<li><strong>Matplotlib</strong> for visualisations</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Load & inspect data:</strong> Loaded the dataset using <code>pd.read_csv()</code> and inspected structure with <code>.info()</code> and <code>.head()</code> to understand column types and missing data. </li>
											<li><strong>Cleaning:</strong> Renamed columns, removed irrelevant rows, and addressed missing values for smoother analysis. </li>
											<li><strong>Initial Exploaration:</strong> Examined fertility rates, population growth, and urban population across income levels and continents.</li>
											<li><strong>Grouping & Summarisation:</strong> Used <code>groupby()</code> and <code>mean()</code> to aggregate indicators by continent and income level.</li>
											<li><strong>Visualisation:</strong> Created scatter plots, line plots, and box plots to reveal relationships between population metrics and economic status.</li>
											
										</ul>

										
										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Plot the BirthRate versus Internet Users categorised by Income Group (Figure 1)
										vis1 = sns.lmplot( data = data, x = 'BirthRate', y = 'InternetUsers', fit_reg = False, hue = 'IncomeGroup', height = 10 )

										# Create the dataframe
										country_data = pd.DataFrame({'CountryName': np.array(Countries_2012_Dataset),
																	'CountryCode': np.array(Codes_2012_Dataset),
																	'CountryRegion': np.array(Regions_2012_Dataset)})

										# Merge country data to the original dataframe (Table 1)
										merged_data = pd.merge(left=data, right=country_data, how='inner', on="CountryCode")
										merged_data.head()

										# Create a data frame with the life expectancy
										life_exp_data = pd.DataFrame({'CountryCode': np.array(Country_Code),
																	'LifeExp1960': np.array(Life_Expectancy_At_Birth_1960),
																	'LifeExp2013': np.array(Life_Expectancy_At_Birth_2013)})

										# Merge the data frame with the life expectancy
										merged_data1 = pd.merge(left=merged_data, right=life_exp_data, how='inner', on='CountryCode')

										# Explore the dataset (Table 2)
										merged_data1.head()

										# Plot the BirthRate versus LifeExpectancy cathegorised by Country Region in 1960 (Figure 3)
										vis3 = sns.lmplot( data = merged_data1, x = 'BirthRate', y = 'LifeExp1960', fit_reg = False, hue = 'CountryRegion', height = 10 )
										Plot

										# Plot the BirthRate versus LifeExpectancy cathegorised by Country Region in 2013 (Figure 4)
										vis4 = sns.lmplot( data = merged_data1, x = 'BirthRate', y = 'LifeExp2013', fit_reg = False, hue = 'CountryRegion', height = 10 )										
										
									
										</code></pre>

										<div class="image-gallery">
											<figure>
												<img 
													src="images/world_dfmerge.png" 
													alt="Table 1: Merged DF" 
													class="gallery-trigger" 
													data-gallery="world-bank" 
													data-caption="Table 1: Merged DF">
												<figcaption><strong>Table 1</strong> Merged DF</figcaption>
											</figure>

											<figure>
												<img 
													src="images/world_dfmerge2.png" 
													alt="Table 2: Merged DF 2" 
													class="gallery-trigger" 
													data-gallery="world-bank" 
													data-caption="Table 2: Merged DF 2">
												<figcaption><strong>Table 2</strong> Merged DF 2</figcaption>
											</figure>

											<figure>
												<img 
													src="images/world_birthintIG.png" 
													alt="Figure 1: BirthRate versus Internet Users categorised by Income Group" 
													class="gallery-trigger" 
													data-gallery="world-bank" 
													data-caption="Figure 1: BirthRate versus Internet Users categorised by Income Group">
												<figcaption><strong>Figure 1</strong> BirthRate versus Internet Users categorised by Income Group</figcaption>
											</figure>

											<figure>
												<img 
													src="images/world_birthintCR.png" 
													alt="Figure 2: BirthRate versus Internet Users categorised by Country Region" 
													class="gallery-trigger" 
													data-gallery="world-bank" 
													data-caption="Figure 2: BirthRate versus Internet Users categorised by Country Region">
												<figcaption><strong>Figure 2</strong> BirthRate versus Internet Users categorised by Country Region</figcaption>
											</figure>

											<figure>
												<img 
													src="images/world_life1960.png" 
													alt="Figure 3: BirthRate versus LifeExpectancy in 1960" 
													class="gallery-trigger" 
													data-gallery="world-bank" 
													data-caption="Figure 3: BirthRate versus LifeExpectancy in 1960">
												<figcaption><strong>Figure 3</strong> BirthRate versus LifeExpectancy in 1960</figcaption>
											</figure>

											<figure>
												<img 
													src="images/world_life2013.png" 
													alt="Figure 4: BirthRate versus LifeExpectancy in 2013" 
													class="gallery-trigger" 
													data-gallery="world-bank" 
													data-caption="Figure 4: BirthRate versus LifeExpectancy in 2013">
												<figcaption><strong>Figure 4</strong> BirthRate versus LifeExpectancy in 2013</figcaption>
											</figure>

										</div>

										

										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>Countries with lower income levels showed higher fertility rates and population growth.</li>
											<li>Urban population tends to correlate with income level, especially in developed regions.</li>
											<li>Africa stands out with higher fertility rates and population growth compared to other continents.</li>
										
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											Filtering and reshaping the dataset for multi-variable analysis was complex due to inconsistent column names and missing data. I solved this by methodically renaming columns and using <code>.dropna()</code> to exclude incomplete records while maintaining dataset integrity.
										</p>
										<p><a href="https://github.com/tendai-codes/Data-Analysis" class="github-button" target="_blank">View on GitHub</a></p>
									</section>


									<section class="project-item" data-tags="Python,Data Analysis">
										<h3>üìΩÔ∏è <strong> Stock Market Analysis </strong></h3>
										<p>
											This project analyzed historical stock price data for major companies and the S&P 500 index to understand price movements, correlations, and daily return patterns. I built an interactive dashboard using Python's data science stack to visualize both raw and normalized stock performance alongside risk metrics.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for data manipulation and analysis</li>
											<li><strong>Pandas</strong> for computations</li>
											<li><strong>Matplotlib & Seaborn</strong> for static visualisations</li>
											<li><strong>Plotly</strong> for interactive charts and dashboards</li>
											<li><strong>NumPy & SciPy</strong> for statistical computations</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Explore data:</strong> Loaded stock price data using <code>pd.read_csv()</code> and explored the dataset structure with <code>.info()</code>, <code>.describe()</code>, and <code>.head()</code> to understand the time series format and identify key stocks. Checked for missing values using <code>.isnull().sum()</code> and calculated basic statistics like mean returns and standard deviation to assess data completeness and variability.</li>
											<li><strong>Price Normalisation:</strong> Created a custom <code>normalize()</code> function to standardize all stock prices to their starting values, enabling fair comparison of relative performance across different price ranges. </li>
											<li><strong>Daily Returns Calculations:</strong> Built a <code>daily_return()</code> function using nested loops to compute percentage daily returns: <code>((current_price - previous_price) / previous_price) * 100</code> for each stock.</li>
											<li><strong>Visualisation:</strong> Developed reusable plotting functions <code>show_plot()</code> and <code>interactive_plot()</code> to create both static matplotlib charts and interactive Plotly visualizations for raw prices, normalized prices, and daily returns.</li>
											<li><strong>Correlation Analysis:</strong> Generated a correlation matrix using <code>.corr()</code> and visualized it with a Seaborn heatmap to identify relationships between stock movements.</li>
											<li><strong>Distribution Analysis:</strong> Created histograms and compiled distribution plots using Plotly's <code>create_distplot()</code> to analyze the statistical properties of daily returns.</li>
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Visualize Stocks data
										def show_plot(df, title):
										df.plot(x = 'Date', figsize=(12, 8), linewidth = 3, title=title)
										plt.xlabel('Date')
										plt.ylabel('Price')
										plt.grid()
										plt.show()

										# Plot the data (Figure 1)
										show_plot(stocks_df, 'STOCKS DATA')
										
										# Normalized Stock Data (Figure 2)
										def normalize(df):
											x = df.copy()
											for i in x.columns[1:]:
												x[i] = x[i]/x[i][0]
											return x

										normalize(stocks_df)

										# Create Interactive chart of Stock Data (Figure 3)

										def interactive_plot(df, title):
										fig = px.line(title=title)

										for i in df.columns[1:]:
											fig.add_scatter(x=df['Date'], y=df[i], name=i)
											fig.update_layout(
											xaxis_title = "Date",
											yaxis_title = "Price"
										)
										fig.show()
										interactive_plot(stocks_df, 'STOCKS DATA')
										
										# Create Interactive chart of Normalized Stock Data (Figure 4)
										interactive_plot(normalize(stocks_df), 'STOCKS DATA')

										#Calculate stocks daily returns

										def daily_return(df):
										df_daily_return = df.copy()
										#loop for columns
										for i in df.columns[1:]:
										#loop for rows
											for j in range(1, len(df)):
											df_daily_return[i][j] = ((df[i][j] - df[i][j-1]) / (df[i][j-1]))*100

											df_daily_return[i][0] = 0

										return df_daily_return


										# Get the daily returns (Figure 5)
										stocks_daily_return = daily_return(stocks_df)
										stocks_daily_return

										interactive_plot(stocks_daily_return, 'Stocks Daily returns')


										# Daily Return Correlation
										cm = stocks_daily_return.drop(columns = ['Date']).corr()
										cm
										
										# heatmap showing correlations (Figure 6)
										plt.figure(figsize=(10, 8))
										sns.heatmap(cm, annot=True, cmap='RdYlGn') #true give you the values on the heatmap
										plt.show()

										# Histogram of daily returns (Figure 7)
										stocks_daily_return.hist(bins=50, figsize=(20, 10))
										plt.show();

										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
										<figure>
											<img src="images/stocks_1.png"
												alt="Figure 1: stocks_1"
												class="gallery-trigger"
												data-gallery="project1"
												data-caption="Figure 1: stocks_1">
											<figcaption><strong>Figure 1</strong></figcaption>
										</figure>

										<figure>
											<img src="images/stocknormal1.png"
												alt="Figure 2: stocknormal1"
												class="gallery-trigger"
												data-gallery="project1"
												data-caption="Figure 2: stocknormal1">
											<figcaption><strong>Figure 2</strong></figcaption>
										</figure>

										<figure>
											<img src="images/stocksdata.png"
												alt="Figure 3: stocksdata"
												class="gallery-trigger"
												data-gallery="project1"
												data-caption="Figure 3: stocksdata">
											<figcaption><strong>Figure 3</strong></figcaption>
										</figure>

										<figure>
											<img src="images/stockdatan.png"
												alt="Figure 4: stocks data normal"
												class="gallery-trigger"
												data-gallery="project1"
												data-caption="Figure 4: stocks data normal">
											<figcaption><strong>Figure 4</strong></figcaption>
										</figure>

										<figure>
											<img src="images/stockdailyr.png"
												alt="Figure 5: stockdailyr"
												class="gallery-trigger"
												data-gallery="project1"
												data-caption="Figure 5: stockdailyr">
											<figcaption><strong>Figure 5</strong></figcaption>
										</figure>

										<figure>
											<img src="images/stockdataheat.png"
												alt="Figure 6: stockdataheat"
												class="gallery-trigger"
												data-gallery="project1"
												data-caption="Figure 6: stockdataheat">
											<figcaption><strong>Figure 6</strong></figcaption>
										</figure>

										<figure>
											<img src="images/stockdatahist.png"
												alt="Figure 7: stockdatahist"
												class="gallery-trigger"
												data-gallery="project1"
												data-caption="Figure 7: stockdatahist">
											<figcaption><strong>Figure 7</strong></figcaption>
										</figure>
									</div>


										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											The daily returns calculation initially produced incorrect values for the first row of each stock. After debugging, the issue was that there's no previous day to calculate a return from for the first entry. This was solved by explicitly setting the first day's return to 0 using <code>df_daily_return[i][0] = 0</code> after the loop calculation, ensuring accurate percentage calculations for all subsequent days.
										</p>
										<p><a href="https://github.com/tendai-codes/Data-Analysis" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,Data Analysis">
										<h3>üìΩÔ∏è <strong>Portfolio Optimization & Risk Analysis </strong></h3>
										<p>
											This project built a comprehensive portfolio management system that simulates random asset allocation across major stocks and calculates key financial metrics including returns, volatility, and risk-adjusted performance. I developed a complete portfolio analytics framework using Python to evaluate investment strategies and portfolio performance over time.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for financial calculations and portfolio modeling</li>
											<li><strong>Pandas</strong> for time series data manipulation and financial computations</li>
											<li><strong>NumPy</strong> for random weight generation and mathematical operations</li>
											<li><strong>Plotly & SciPy</strong> for interactive portfolio performance visualisation, statistical analysis and risk metrics </li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Data Preparation:</strong> Loaded and sorted stock data chronologically using <code>sort_values()</code> by Date to ensure proper time series analysis for portfolio calculations. </li>
											<li><strong>Random Portfolio Generation:</strong> Used <code>np.random.seed()</code> and <code>np.random.seed(9)</code> to create randomized asset allocation weights, then normalized them using <code>weights / np.sum(weights)</code> to ensure they sum to 100%. </li>
											<li><strong>Portfolio Normalisation:</strong> Applied a custom normalize() function to standardize all stock prices to their initial values, creating a baseline for relative performance comparison across different price ranges.</li>
											<li><strong>Portfolio function development:</strong> Built a reusable <code>portfolio_allocation()</code> function that encapsulates the entire workflow for testing different weight combinations and portfolio strategies.</li>
											<li><strong>Risk metrics calculation:</strong> Computed cumulative return, standard deviation (volatility), average daily return, and Sharpe ratio (assessesment of the risk-adjusted returns of an investment) using <code>np.sqrt(252)</code> for annualization.</li>
										
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python">#Create random portfolio weights
										np.random.seed()

										# Create random weights for the stocks
										weights = np.array(np.random.random(9))

										# Random Asset Allocation & Calculate Portfolio Daily Return
										weights = weights / np.sum(weights)
										print(weights)

										# Define Normalization function
										def normalize(df):
										x = df.copy()
										for i in x.columns[1:]:
											x[i] = x[i]/x[i][0]
										return x

										# Enumerate returns the value and a counter as well
										for counter, stock in enumerate(df_portfolio.columns[1:]):
										df_portfolio[stock] = df_portfolio[stock] * weights[counter]
										df_portfolio[stock] = df_portfolio[stock] * 1000000
										df_portfolio

										# Calculate the portfolio daily return

										df_portfolio['portfolio daily % return'] = 0.0000

										for i in range(1, len(stocks_df)):
										# Calculate the percentage of change from the previous day
										df_portfolio['portfolio daily % return'][i] = ( (df_portfolio['portfolio daily worth/$'][i] - df_portfolio['portfolio daily worth/$'][i-1]) / df_portfolio['portfolio daily worth/$'][i-1]) * 100

										df_portfolio

										# Create a function for stock portfolio allocation
										# Assume $1000000 is total amount for portfolio

										def portfolio_allocation(df, weights):

										df_portfolio = df.copy()

										# Normalize the stock avalues
										df_portfolio = normalize(df_portfolio)

										for counter, stock in enumerate(df_portfolio.columns[1:]):
											df_portfolio[stock] = df_portfolio[stock] * weights[counter]
											df_portfolio[stock] = df_portfolio[stock] * 1000000

										df_portfolio['portfolio daily worth in $'] = df_portfolio[df_portfolio != 'Date'].sum(axis = 1)

										df_portfolio['portfolio daily % return'] = 0.0000

										for i in range(1, len(stocks_df)):

										# Calculate the percentage of change from the previous day
											df_portfolio['portfolio daily % return'][i] = ( (df_portfolio['portfolio daily worth in $'][i] - df_portfolio['portfolio daily worth in $'][i-1]) / df_portfolio['portfolio daily worth in $'][i-1]) * 100

										# Set the value of first row to zero, as previous value is not available
										df_portfolio['portfolio daily % return'][0] = 0
										return df_portfolio

										# Plot the portfolio daily return (Figure 1)
										fig = px.line(x = df_portfolio.Date, y = df_portfolio['portfolio daily % return'], title = 'Portfolio Daily % Return',
													labels = {
															"x": "Date",
															"y": "Daily Percentage Return"
														})
										fig.show()

										# Cummulative return of the portfolio
										cummulative_return = ((df_portfolio['portfolio daily worth/$'][-1:] - df_portfolio['portfolio daily worth/$'][0])/ df_portfolio['portfolio daily worth/$'][0]) * 100
										print('Cummulative return of the portfolio is {} %'.format(cummulative_return.values[0]))

										# Calculate the average daily return
										print('Average daily return of the portfolio is {} %'.format(df_portfolio['portfolio daily % return'].mean() ))

										# Portfolio sharpe ratio
										sharpe_ratio = df_portfolio['portfolio daily % return'].mean() / df_portfolio['portfolio daily % return'].std() * np.sqrt(252)
										print('Sharpe ratio of the portfolio is {}'.format(sharpe_ratio))

										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img 
												src="images/portfoliodaily.png" 
												alt="Figure 1: Portfolio Daily Returns (%)" 
												class="gallery-trigger" 
												data-gallery="portfolio-assets" 
												data-caption="Figure 1: Portfolio Daily Returns (%)">
												<figcaption><strong>Figure 1</strong> Portfolio Daily Returns (%)</figcaption>
											</figure>
										</div>



										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>Random portfolio allocation provides baseline performance benchmarks for comparing against optimized strategies, revealing how diversification across 9 stocks performs under equal-weight and random-weight scenarioss</li>
											<li>Daily return volatility patterns indicate portfolio risk characteristics with higher volatility periods corresponding to market stress, while Sharpe ratio quantifies whether returns adequately compensate for risk takeno</li>
											<li>Normalization to Day 1 baseline enables fair comparison across stocks with different price levels, allowing proper weight allocation based on percentage changes rather than absolute dollar amounts</li>
											<li>Cumulative returns demonstrated the compound effect of daily performance over the investment period</li>
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											I initially encountered an indexing error when calculating portfolio daily returns because I was trying to access the previous day's value for the first row, which doesn't exist. The calculation <code>df_portfolio['portfolio daily % return'][i-1]</code> failed on the first iteration. I solved this by explicitly setting the first day's return to 0 using <code>df_portfolio['portfolio daily % return'][0] = 0</code> after the loop, and ensuring the loop started from index 1 rather than 0. This approach properly handled the edge case while maintaining accurate percentage calculations for all subsequent trading days.
										</p>
										<p><a href="https://github.com/tendai-codes/Data-Analysis" class="github-button" target="_blank">View on GitHub</a></p>
									</section>


									<section class="project-item" data-tags="Python,Data Analysis">
										<h3>üìΩÔ∏è <strong>Understanding Market Exposure: A CAPM-Based Stock Evaluation </strong></h3>
										<p>
											This project emerged from a natural curiosity sparked during my earlier stock market analysis, where I explored daily return patterns and volatility trends. That initial exploration raised deeper questions: <em>How do individual stocks behave in relation to market-wide movements?</em> <em>Can risk be quantified and priced?</em> These questions led me to explore <strong>Beta</strong> (market sensitivity), <strong>Alpha</strong> (excess returns), and the <strong>Capital Asset Pricing Model</strong> (CAPM)‚Äîa foundational framework in modern finance.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for financial calculations and statistical analysis</li>
											<li><strong>Pandas</strong> for time series data manipulation and daily returns calculations </li>
											<li><strong>NumPy</strong> for linear regression and polynomial fitting</li>
											<li><strong>Seaborn</strong> for enhanced statistical plotting capabilities</li>
											<li><strong>Plotly Express</strong> for interactive CAPM analysis charts</li>
											<li><strong>Matplotlib</strong> for static scatter plots and regression line visualisation</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Market benchmark analysis:</strong> Used S&P 500 as the market proxy and calculated average daily returns using <code>.drop('Date', axis=1).mean()</code> to establish baseline market performance. </li>
											<li><strong>Beta & Alpha computation:</strong> Applied <code>np.polyfit()</code> with order=1 to perform linear regression between individual stock returns and S&P 500 returns, extracting beta (slope) and alpha (intercept) coefficients. </li>
											<li><strong>Batch analysis automation:</strong> Developed loops to iterate through all stocks (excluding S&P 500 and Date columns) using conditional statements <code>if i != 'sp500'</code> and <code>i != 'Date'</code> to calculate beta and alpha for each stock systematically.</li>
											<li><strong>Interactive dashboard creation:</strong> Built Plotly Express scatter plots with <code>px.scatter()</code> and added regression lines using <code>fig.add_scatter()</code> to create interactive CAPM analysis charts for each stock.</li>
											<li><strong>Risk metrics storage:</strong> Used Python dictionaries <code>beta = {}</code> and <code>alpha = {}</code> to store calculated coefficients for each stock, enabling easy comparison and further analysis. </li>
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Function to calculate the daily returns
										def daily_returns(df):
										df_daily_return = df.copy()
										for i in df.columns[1:]:
											for j in range(1, len(df)):
											df_daily_return[i][j] = ((df[i][j] - df[i][j-1])/df[i][j-1])*100

											df_daily_return[i][0] = 0
										return df_daily_return

										# Plot a scatter plot between the selected stock and the S&P500 (Market) (Figure 1)
										plt.scatter(stocks_daily_return['sp500'], stocks_daily_return['AAPL'])
										plt.xlabel('sp500')
										plt.ylabel('AAPL')
										plt.grid()

										# Add beta & alpha to plot
										beta, alpha = np.polyfit(stocks_daily_return['sp500'], stocks_daily_return['AAPL'], 1)

										# Add regression line (beta) - y = beta [stockvsmkt- stock volatility] * rm [stock daily return] + alpha [excess return on top of mkt return]
										plt.plot(stocks_daily_return['sp500'], beta * stocks_daily_return['sp500'] + alpha, '-', color = 'r')
										plt.show()

										# Let's calculate the annualized rate of return for S&P500 (Assume 252 working days per year)

										rm = stocks_daily_return['sp500'].mean() * 252
										rm

										# Assume risk free rate is zero (Used the yield of a 10-years U.S. Government bond as a risk free rate)
										rf = 0

										# Calculate return for any security (APPL) using CAPM
										Exp_return_AAPL = rf + (beta * (rm - rf))
										Exp_return_AAPL

										# Create a placeholder for all betas and alphas
										beta = {}
										alpha = {}

										for i in stocks_daily_return.columns[1:]:
										if i != 'sp500'and i != 'Date':

											stocks_daily_return.plot(kind = 'scatter', x = 'sp500', y = i, title = i)
											plt.scatter(stocks_daily_return['sp500'], stocks_daily_return[i])
											plt.xlabel('sp500')
											plt.ylabel(i)
											beta[i], alpha[i] = np.polyfit(stocks_daily_return['sp500'], stocks_daily_return[i], 1)
											plt.plot(stocks_daily_return['sp500'], beta[i] * stocks_daily_return['sp500'] + alpha[i], '-', color = 'r')

											plt.grid()
											plt.show()

											
										print('Beta for {} stock is {} & alpha is = {}'.format('AAPL', beta, alpha))


										# Apply CAPM formula to calculate the return for the Portfolio
										# Obtain a list of all stock names
										stock_names = list(beta.keys())
										stock_names

										# Define the expected return dictionary
										ER = {}

										rf = 0
										rm = stocks_daily_return['sp500'].mean() * 252
										for i in stock_names:
										ER[i] = rf + (beta[i] * (rm - rf))
										ER

										for i in stock_names:
										print('Expected return for {} is {}%'.format(i, ER[i]))

										Portfolio_weights = 1/8 * np.ones(8)

										# Assume equal weights in the portfolio, calculate returns
										ER_portfolio = sum(list(ER.values()) * Portfolio_weights)
										ER_portfolio
										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/CAPM.png" 
													alt="Figure 1: Stock Daily Returns"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Figure 1: Stock Daily Returns">
												<figcaption><strong>Figure 1</strong></figcaption>
											</figure>
										</div>

										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>Beta values revealed which stocks were more volatile than the market (beta > 1) versus defensive stocks (beta < 1)</li>
											<li>Alpha coefficients identified stocks generating excess returns above what CAPM predicted</li>
											<li>The regression analysis showed how closely each stock's movements correlated with overall market trends</li>
											<li>Visual scatter plots revealed the strength of linear relationships between individual stocks and market performance</li>
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											I initially struggled with the loop logic for batch processing all stocks because I was accidentally including the S&P 500 index in the analysis against itself, which created perfect correlation (beta = 1, alpha = 0) and distorted my results. After debugging, I realized I needed to exclude both 'sp500' and 'Date' columns using compound conditional statements <code>if i != 'sp500'</code> and <code>i != 'Date'</code>. This solution ensured I only analyzed actual stocks against the market benchmark, providing meaningful beta and alpha calculations for investment decision-making.
										</p>
										<p><a href="https://github.com/tendai-codes/Data-Analysis" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,Machine Learning">
										<h3>üìΩÔ∏è <strong>Startup Revenue Prediction Model  </strong></h3>
										<p>
											This project built a multiple linear regression model to predict startup profitability based on their R&D spending, administration costs, marketing expenditure, and location. I implemented a complete machine learning pipeline using scikit-learn to analyze which factors most strongly influence startup success and revenue generation.

										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development</li>
											<li><strong>Scikit-learn</strong> for preprocessing, model training, and evaluation</li>
											<li><strong>Pandas</strong> for dataset loading and initial data exploration</li>
											<li><strong>Matplotlib</strong> for data visualisations</li>
											<li><strong>NumPy</strong> for numerical array operations and precision control</li>
											
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Data import & separation:</strong> Loaded the 50 Startups dataset using <code>pd.read_csv()</code> and strategically separated features (X) from the target variable (y) using <code>.iloc[:, -1]</code> for all columns except the last, and <code>.iloc[:, -1]</code> for the dependent variable (profit). </li>
											<li><strong>Categorical Encoding:</strong> Applied One-Hot Encoding using <code>ColumnTransformer</code> and <code>OneHotEncoder()</code> to convert the categorical 'State' variable (column index [3]) into numerical dummy variables, while keeping other numerical features intact using <code>remainder='passthrough'</code>. </li>
											<li><strong>Data transformation, model training & prediction:</strong> Used <code>np.array(ct.fit_transform(X))</code> to convert the transformed data back into a NumPy array format suitable for machine learning algorithms. Implemented <code>train_test_split()</code> with an 80-20 split <code>(test_size=0.2)</code> and fixed random state <code>(random_state=0)</code> to ensure reproducible results and proper model validation. Instantiated and trained a <code>LinearRegression()</code> model using <code>.fit(X_train, y_train)</code> to learn the relationships between startup characteristics and profitability. Generated predictions on the test set using <code>regressor.predict(X_test)</code> to evaluate model performance on unseen data.</li>
											<li><strong>Results Visualisation:</strong> Used <code>np.set_printoptions(precision=2)</code> for clean output formatting and <code>np.concatenate()</code> with <code>reshape()</code> to create side-by-side comparison of predicted vs. actual values for easy performance assessment.</li>
											
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Encoding categorical data 
										from sklearn.compose import ColumnTransformer
										from sklearn.preprocessing import OneHotEncoder

										# OneHotEncoder(), [3] - the 3 is the column you want to encode
										ct = ColumnTransformer(transformers=[('encoder', OneHotEncoder(), [3])], remainder='passthrough')
										X = np.array(ct.fit_transform(X))

										# Splitting Train ad Test set
										from sklearn.model_selection import train_test_split
										X_train, X_test, y_train, y_test = train_test_split(X, y, test_sise = 0.2, random_state = 0)

										from sklearn.linear_model import LinearRegression
										regressor = LinearRegression()
										regressor.fit(X_train, y_train)

										# Predicting Results
										y_pred = regressor.predict(X_test)
										np.set_printoptions(precision=2)
										print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))

										# Evaluating the Model Performance
										from sklearn.metrics import r2_score
										r2_score(y_test, y_pred)
										</code></pre>

										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/startup_table1.png" 
													alt="Figure 1: startup"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Figure 1: startup">
												<figcaption><strong>Figure 1</strong> Model Evaluation</figcaption>
											</figure>
										</div>


										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>The model successfully learned to predict startup profitability based on spending patterns across R&D, administration, and marketing</li>
											<li>One-hot encoding effectively handled the categorical state variable, allowing the model to capture location-based effects on startup success</li>
											<li>The side-by-side prediction comparison revealed the model's accuracy in forecasting startup revenue</li>
											<li>Multiple linear regression proved effective for understanding the linear relationships between various business expenditures and profitability</li>
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											The array reshaping and concatenation for results display presented a significant hurdle because the predicted and actual values were 1D arrays that couldn't be directly concatenated horizontally. The error occurred when trying to use <code>np.concatenate()</code> without proper dimensionality. This was solved by using <code>reshape(len(y_pred),1)</code> to convert both arrays into column vectors (2D arrays with one column), then applying horizontal concatenation with the parameter 1 to stack them side-by-side. This approach created a clean comparison matrix showing predicted values next to actual values, making model performance evaluation much more intuitive.
										</p>
										<p><a href="https://github.com/tendai-codes/your-project" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,Machine Learning">
										<h3>üìΩÔ∏è <strong>HR Salary Prediction: Model Comparison </strong></h3>
										<p>
											This project implemented and compared five different regression algorithms to predict employee salaries based on position levels within an organization. I built a comprehensive machine learning pipeline comparing linear regression, polynomial regression, support vector regression (SVR), decision tree regression, and random forest regression to identify the optimal model for HR compensation analysis.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development and comparison</li>
											<li><strong>Scikit-learn</strong> for multiple regression algorithms, feature scaling, and model training</li>
											<li><strong>Pandas</strong> for dataset loading and initial data exploration</li>
											<li><strong>Matplotlib</strong> for data visualisations</li>
											<li><strong>NumPy</strong> for numerical operations and grid generation</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Data Preparation:</strong> Loaded position-salary dataset using <code>pd.read_csv()</code> and extracted features using <code>iloc[:, 1:-1]</code> (position levels) and target variable using <code>iloc[:, -1]</code>  (salaries), strategically excluding the first column containing position titles. </li>
											<li><strong>Linear regression baseline:</strong> Implemented a standard<code>LinearRegression()</code>  model using <code>.fit(X, y)</code> to establish a baseline for salary prediction based on position level with a straight-line relationship. </li>
											<li><strong>Polynomial feature engineering: </strong> Applied <code>PolynomialFeatures(degree=4)</code>  to transform the single position level feature into polynomial terms (x, x¬≤, x¬≥, x‚Å¥), creating a richer feature space to capture non-linear salary progression patterns.</li>
											<li><strong>Support Vector Regression: </strong> Implemented feature scaling using <code>StandardScaler()</code>for both X and y variables, then trained an SVR model with <code>RBF kernel</code> to handle non-linear relationships while managing the different scales between position levels and salary amounts.</li>
											<li><strong>Decision Tree : </strong> Built a <code>DecisionTreeRegressor()</code> model that creates hierarchical decision rules to predict salaries, capturing complex non-linear patterns without requiring feature scaling.</li>
											<li><strong>Random Forest Regression: </strong> Implemented <code>RandomForestRegressor()</code> with multiple decision trees to reduce overfitting and improve prediction stability through ensemble learning.</li>
											<li><strong>Polynomial feature engineering: </strong> Applied <code>PolynomialFeatures(degree=4)</code>  to transform the single position level feature into polynomial terms (x, x¬≤, x¬≥, x‚Å¥), creating a richer feature space to capture non-linear salary progression patterns.</li>
											<li><strong>Random Forest Regression: </strong> Implemented <code>RandomForestRegressor()</code> with multiple decision trees to reduce overfitting and improve prediction stability through ensemble learning.</li>
											<li><strong>SVR Inverse scaling: </strong> Applied <code>sc_X.inverse_transform()</code> and <code>sc_y.inverse_transform()</code> to convert scaled predictions back to original salary units, with proper reshaping using <code>.reshape(-1, 1)</code> for visualization.</li>
										
											<li><strong>Model Visualisations:</strong> Created scatter plots with <code>plt.scatter()</code> for actual data points and <code>plt.plot()</code> for the linear regression line, showing the limitation of straight-line salary prediction. Generated similar visualizations for the polynomial model using <code>lin_reg_2.predict(poly_reg.fit_transform(X))</code> to display the curved relationship between position levels and salaries.</li>
											<li><strong>Model comparison:</strong> Made direct salary predictions for position level 6.5 using both <code>lin_reg.predict([[6.5]])</code> and <code>lin_reg_2.predict(poly_reg.fit_transform([[6.5]]))</code> to compare model outputs for intermediate position levels.</li>
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing Libraries	
										import numpy as np
										import matplotlib.pyplot as plt
										import pandas as pd

										# Importing dataset	
										dataset = pd.read_csv('Position_Salaries.csv')
										X = dataset.iloc[:, 1:-1].values
										y = dataset.iloc[:, -1].values


										# Training the Decision Tree Regression
										from sklearn.tree import DecisionTreeRegressor
										regressor = DecisionTreeRegressor(random_state = 0)
										regressor.fit(X, y)

										# Predicting New Result
										regressor.predict([[6.5]])

										# Visualising Results (Figure 1)

										X_grid = np.arange(min(X), max(X), 0.01)
										# 0.01 was adjusted from 0.1 to increase the resolution
										X_grid = X_grid.reshape((len(X_grid), 1))
										plt.scatter(X, y, color = 'red')
										plt.plot(X_grid, regressor.predict(X_grid), color = 'blue')
										plt.title('HR Salary Predictions (Decision Tree Regression)')
										plt.xlabel('Position level')
										plt.ylabel('Salary')
										plt.show()

										
										# Evaluating the Model Performance 
										from sklearn.metrics import r2_score
										# Since the model was trained on the whole dataset, we    evaluate on the whole dataset
										y_pred = regressor.predict(X)
										r2_score(y, y_pred)

										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/HR_linReg.png" 
													alt="Linear Regression Model"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 1: Linear Regression Model">
												<figcaption><strong>Figure 1</strong> Linear Regression</figcaption>
											</figure>

											<figure>
												<img src="images/HReval_linReg.png" 
													alt="Linear Regression Evaluation"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 1a: Linear Regression Model Evaluation">
												<figcaption><strong>Figure 1a</strong> Model Evaluation ‚Äì Linear Regression</figcaption>
											</figure>

											<figure>
												<img src="images/HR_polyReg.png" 
													alt="Polynomial Regression Model"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 2: Polynomial Regression Model">
												<figcaption><strong>Figure 2</strong> Polynomial Regression</figcaption>
											</figure>

											<figure>
												<img src="images/HReval_polyReg.png" 
													alt="Polynomial Regression Evaluation"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 2a: Polynomial Regression Model Evaluation">
												<figcaption><strong>Figure 2a</strong> Model Evaluation ‚Äì Polynomial Regression</figcaption>
											</figure>

											<figure>
												<img src="images/HR_svr.png" 
													alt="SVR Model"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 3: Support Vector Regression Model">
												<figcaption><strong>Figure 3</strong> SVR</figcaption>
											</figure>

											<figure>
												<img src="images/HReval_svr.png" 
													alt="SVR Evaluation"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 3a: Support Vector Regression Model Evaluation">
												<figcaption><strong>Figure 3a</strong> Model Evaluation ‚Äì SVR</figcaption>
											</figure>

											<figure>
												<img src="images/HR_Randfor.png" 
													alt="Random Forest Model"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 4: Random Forest Model">
												<figcaption><strong>Figure 4</strong> Random Forest</figcaption>
											</figure>

											<figure>
												<img src="images/HReval_Randfor.png" 
													alt="Random Forest Evaluation"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 4a: Random Forest Model Evaluation">
												<figcaption><strong>Figure 4a</strong> Model Evaluation ‚Äì Random Forest</figcaption>
											</figure>

											<figure>
												<img src="images/HR_DecT.png" 
													alt="Decision Tree Model"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 5: Decision Tree Model">
												<figcaption><strong>Figure 5</strong> Decision Tree</figcaption>
											</figure>

											<figure>
												<img src="images/HReval_DecT.png" 
													alt="Decision Tree Evaluation"
													class="gallery-trigger" 
													data-gallery="salary-prediction" 
													data-caption="Figure 5a: Decision Tree Model Evaluation">
												<figcaption><strong>Figure 5a</strong> Model Evaluation ‚Äì Decision Tree</figcaption>
											</figure>
										</div>


										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
										<strong> N.B: </strong> <em> Due to small dataset there is no train-test split to avoid model overfitting</em>
											<li>Linear regression showed limitations in capturing the exponential nature of executive compensation at higher position levels</li>
											<li>Polynomial regression successfully modeled smooth non-linear salary curves typical in corporate hierarchies</li>
											<li>SVR with proper scaling handled the high salary variance effectively while maintaining smooth predictions</li>
											<li>Decision tree regression captured salary jumps at specific position levels but risked overfitting</li>
											<li>Random forest regression provided stable predictions by averaging multiple decision trees, reducing variance</li>
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											
											The SVR model visualization presented scaling complications because support vector regression requires feature scaling for optimal performance, but the visualization needed to display results in original salary units. The challenge was handling the forward and inverse transformations correctly. This was resolved by implementing a multi-step process: using  <code>sc_X.transform(X_grid)</code> to scale the grid for SVR prediction, then applying <code>sc_y.inverse_transform()</code>  to convert predictions back to actual salary values, with careful attention to array reshaping using <code>.reshape(-1, 1)</code> to maintain proper dimensionality throughout the scaling pipeline. This approach ensured accurate model performance while maintaining interpretable visualizations in original salary units.
										</p>
										<p><a href="https://github.com/tendai-codes/your-project" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,Machine Learning">
										<h3>üìΩÔ∏è <strong> Customer Purchase Prediction ‚Äì Model Comparison & Optimization </strong></h3>
										<p>
											This project involved comparing multiple classification algorithms to predict whether users would purchase a product based on their age and estimated salary from social network advertisement data. I tested various models including Logistic Regression, SVM, Kernel SVM, Naive Bayes, K-NN, Random Forest, and Decision Tree. The Decision Tree classifier yielded the best results, which is why I've included its implementation in my portfolio.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development and comparison</li>
											<li><strong>Scikit-learn</strong> for machine learning model implementation and evaluation</li>
											<li><strong>Pandas</strong> for dataset loading and initial data exploration</li>
											<li><strong>Matplotlib</strong> for creating decision boundary visualizations and scatter plots</li>
											<li><strong>NumPy</strong> for numerical operations and grid generation</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Model Comparison & selection:</strong> Tested multiple classification algorithms (Logistic Regression, SVM, Kernel SVM, Naive Bayes, K-NN, Random Forest, and Decision Tree) to identify the best-performing model for this dataset. </li>
											<li><strong>Data Import & Preparation:</strong> Loaded the Social Network Ads dataset using pandas and separated features (age, salary) from the target variable (purchase decision). </li>
											<li><strong>Data Splitting: </strong> Used <code>train_test_split()</code> to divide the dataset into 75% training and 25% testing sets with a fixed random state for reproducibility.</li>
											<li><strong>Feature scaling: </strong> Applied <code>StandardScaler</code> to normalize both age and salary features, ensuring equal contribution to the model since salary values are much larger than age values.</li>
											<li><strong>Model Training: </strong> Implemented and trained seven different classifiers on the scaled training data: <code>LogisticRegression</code>, <code>SVC (linear and RBF kernel)</code>, <code>GaussianNB</code>, <code>KNeighborsClassifier</code>, <code>RandomForestClassifier</code>, and <code>DecisionTreeClassifier</code> with entropy criterion.</li>
											<li><strong>Model Evaluation: </strong> Generated predictions on the test set and created a confusion matrix to assess classification performance and calculate accuracy score..</li>
											<li><strong>Decision Boundary Visualization feature engineering: </strong> Created contour plots showing decision boundaries for both training and test sets, with red and green regions representing different classification zones.</li>
											
										</ul>
										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing Libraries	
										import numpy as np
										import matplotlib.pyplot as plt
										import pandas as pd

										# Importing Dataset
										dataset = pd.read_csv('Social_Network_Ads.csv')
										X = dataset.iloc[:, :-1].values
										y = dataset.iloc[:, -1].values

										# Splitting dataset into Training & Test set
										from sklearn.model_selection import train_test_split
										X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)

										print(X_train), print(X_test)
										print(y_train), print(y_test)

										# Feature Scaling
										from sklearn.preprocessing import StandardScaler
										sc = StandardScaler()
										X_train = sc.fit_transform(X_train)
										X_test = sc.transform(X_test)

										print(X_train), print(X_test)

										# Training Decision tree classification Model
										from sklearn.tree import DecisionTreeClassifier
										classifier = DecisionTreeClassifier(criterion = 'entropy', random_state = 0)
										classifier.fit(X_train, y_train)

										# Predicting Test Results
										y_pred = classifier.predict(X_test)
										print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))

										# Making Confusion Matrix 
										from sklearn.metrics import confusion_matrix, accuracy_score
										cm = confusion_matrix(y_test, y_pred)
										print(cm)
										accuracy_score(y_test, y_pred)

										#Visualising Training set results 
										from matplotlib.colors import ListedColormap
										X_set, y_set = sc.inverse_transform(X_train), y_train
										X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 10, stop = X_set[:, 0].max() + 10, step = 0.25),
															np.arange(start = X_set[:, 1].min() - 1000, stop = X_set[:, 1].max() + 1000, step = 0.25))
										plt.contourf(X1, X2, classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),
													alpha = 0.75, cmap = ListedColormap(('red', 'green')))
										plt.xlim(X1.min(), X1.max())
										plt.ylim(X2.min(), X2.max())
										for i, j in enumerate(np.unique(y_set)):
											plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1], c = ListedColormap(('red', 'green'))(i), label = j)
										plt.title('Decision Tree Classification (Training set)')
										plt.xlabel('Age')
										plt.ylabel('Estimated Salary')
										plt.legend()
										plt.show()

										#Visualising Test set results 
										from matplotlib.colors import ListedColormap
										X_set, y_set = sc.inverse_transform(X_test), y_test
										X1, X2 = np.meshgrid(np.arange(start = X_set[:, 0].min() - 10, stop = X_set[:, 0].max() + 10, step = 0.25),
															np.arange(start = X_set[:, 1].min() - 1000, stop = X_set[:, 1].max() + 1000, step = 0.25))
										plt.contourf(X1, X2, classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),
													alpha = 0.75, cmap = ListedColormap(('red', 'green')))
										plt.xlim(X1.min(), X1.max())
										plt.ylim(X2.min(), X2.max())
										for i, j in enumerate(np.unique(y_set)):
											plt.scatter(X_set[y_set == j, 0], X_set[y_set == j, 1], c = ListedColormap(('red', 'green'))(i), label = j)
										plt.title('Decision Tree Classification (Test set)')
										plt.xlabel('Age')
										plt.ylabel('Estimated Salary')
										plt.legend()
										plt.show()
										</code></pre>

										
										<!-- Visualisations -->
										<div class="image-gallery">
											<figure>
												<img src="images/Salary_logR.png" 
													alt="Logistic Regression visualization"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Logistic Regression Model">
												<figcaption><strong>Figure 1</strong> Logistic Regression</figcaption>
											</figure>

											<figure>
												<img src="images/salary_logRT.png" 
													alt="Logistic Regression performance metrics"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Logistic Regression Results">
												<figcaption><strong>Table 1</strong> Logistic Regression Metrics</figcaption>
											</figure>

											<figure>
												<img src="images/Salary_svm.png" 
													alt="Support Vector Machine visualization"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="SVM Model">
												<figcaption><strong>Figure 2</strong> Support Vector Machine</figcaption>
											</figure>

											<figure>
												<img src="images/salary_svmT.png" 
													alt="SVM performance metrics"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="SVM Results">
												<figcaption><strong>Table 2</strong> SVM Metrics</figcaption>
											</figure>

											<figure>
												<img src="images/Salary_kernsvm.png" 
													alt="Kernel SVM visualization"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Kernel SVM Model">
												<figcaption><strong>Figure 3</strong> Kernel SVM</figcaption>
											</figure>

											<figure>
												<img src="images/salary_kernsvmT.png" 
													alt="Kernel SVM performance metrics"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Kernel SVM Results">
												<figcaption><strong>Table 3</strong> Kernel SVM Metrics</figcaption>
											</figure>

											<figure>
												<img src="images/Salary_naive.png" 
													alt="Naive Bayes visualization"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Naive Bayes Model">
												<figcaption><strong>Figure 4</strong> Naive Bayes</figcaption>
											</figure>
											
											<figure>
												<img src="images/salary_naiveT.png" 
													alt="Naive Bayes performance metrics"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Naive Bayes Results">
												<figcaption><strong>Table 4</strong> Naive Bayes Metrics</figcaption>
											</figure>

											<figure>
												<img src="images/Salary_knn.png" 
													alt="K-Nearest Neighbors visualization"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="KNN Model">
												<figcaption><strong>Figure 5</strong> K-Nearest Neighbors</figcaption>
											</figure>

											<figure>
												<img src="images/salary_knnT.png" 
													alt="KNN performance metrics"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="KNN Results">
												<figcaption><strong>Table 5</strong> KNN Metrics</figcaption>
											</figure>

											<figure>
												<img src="images/Salary_random.png" 
													alt="Random Forest visualization"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Random Forest Model">
												<figcaption><strong>Figure 6</strong> Random Forest</figcaption>
											</figure>
											
											<figure>
												<img src="images/salary_randomT.png" 
													alt="Random Forest performance metrics"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Random Forest Results">
												<figcaption><strong>Table 6</strong> Random Forest Metrics</figcaption>
											</figure>

											<figure>
												<img src="images/Salary_dectree.png" 
													alt="Decision Tree visualization"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Decision Tree Model">
												<figcaption><strong>Figure 7</strong> Decision Tree</figcaption>
											</figure>

											<figure>
												<img src="images/salary_dectreeT.png" 
													alt="Decision Tree performance metrics"
													class="gallery-trigger"
													data-gallery="salary-network"
													data-caption="Decision Tree Results">
												<figcaption><strong>Table 7</strong> Decision Tree Metrics</figcaption>
											</figure>
										</div>


										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>Decision Tree outperformed six other classification models including Logistic Regression, SVM variants, Naive Bayes, K-NN, and Random Forest, demonstrating superior accuracy for this specific age-salary prediction task</li>
											<li>Feature scaling significantly improved model performance across all algorithms by preventing salary values from dominating the decision-making process due to their larger magnitude compared to age values</li>
											<li>Visual analysis revealed clear classification patterns where younger, lower-salary individuals and older, higher-salary individuals showed different purchasing behaviors, with the winning Decision Tree model capturing these complex relationships most effectively</li>
										
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											
											At first, the visualisations were hard to understand because the data had been scaled. The age and salary values didn‚Äôt look realistic in the plots. I solved this by converting the data back to its original scale before plotting. This made the decision areas easier to read and relate to real-life values.
										</p>
										<p><a href="https://github.com/tendai-codes/Machine-learning" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,Machine Learning">
										<h3>üìΩÔ∏è <strong>Breast Cancer Classification: Multi-Algorithm Comparison </strong></h3>
										<p>
											This project implemented and compared six different machine learning classification algorithms to predict breast cancer diagnosis (malignant vs benign) based on cellular characteristics. I built a comprehensive medical classification pipeline using multiple algorithms to identify the most effective approach for cancer detection and diagnosis support.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development and comparison</li>
											<li><strong>Scikit-learn</strong> for multiple classification algorithms, preprocessing, and evaluation metrics</li>
											<li><strong>Pandas</strong> for dataset loading and initial data exploration</li>
											<li><strong>Matplotlib</strong> for data visualisationsand model performance analysis</li>
											<li><strong>NumPy</strong> for numerical operations and grid generation</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Load & inspect data:</strong> Loaded breast cancer dataset using <code>pd.read_csv()</code> and separated cellular features (X) from diagnosis labels (y) using <code>iloc[:, :-1]</code> and <code>iloc[:, -1]</code> respectively, ensuring proper handling of medical diagnostic data. </li>
											<li><strong>Train-test stratification:</strong> Applied <code>train_test_split()</code> with 75-25 split (<code>test_size=0.25</code>) and fixed random state for reproducible medical model evaluation, crucial for healthcare applications. </li>
											<li><strong>Feature standardization:</strong> Implemented <code>StandardScaler()</code> using <code>fit_transform()</code> on training data and <code>transform()</code> on test data to normalize cellular measurements across different scales without data leakage.</li>
											<li><strong>Logistic Regression: </strong> Built a <code>LogisticRegression(random_state=0)</code> model as the statistical baseline for binary medical classification, providing interpretable probability outputs for clinical decision-making.</li>
											<li><strong>Support Vector Machine (Linear):</strong> Implemented <code>SVC(kernel='linear')</code> to find optimal linear decision boundaries for separating malignant from benign cases using maximum margin principles.</li>
											<li><strong>Decision Tree Classification: </strong> Applied <code>DecisionTreeClassifier(criterion='entropy')</code> to create interpretable rule-based diagnostic pathways that clinicians can follow and understand.</li>
											<li><strong>K-Nearest Neighbors:</strong> Used <code>KNeighborsClassifier(n_neighbors=5, metric='minkowski', p=2)</code> to classify cases based on similarity to neighboring data points, leveraging local patterns in cellular characteristics.</li>
											<li><strong>Support Vector Machine (RBF):</strong> Implemented <code>SVC(kernel='rbf')</code> with radial basis function kernel to capture complex non-linear relationships in cellular feature space.</li>
											<li><strong>Naive Bayes: </strong> Applied <code>GaussianNB()</code> assuming feature independence to provide probabilistic classification based on Bayesian statistics, suitable for medical diagnostic scenarios.</li>
											<li><strong>Performance evaluation: </strong> Generated predictions using <code>classifier.predict(X_test)</code> and evaluated each model using <code>confusion_matrix()</code> and <code>accuracy_score()</code> to assess diagnostic accuracy and error patterns.</li>
											<li><strong>Medical model validation: </strong> Created confusion matrices to analyze true positives, false positives, true negatives, and false negatives - critical metrics for medical diagnostic applications where false negatives (missed cancers) are particularly concerning..</li>

										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing the libraries
										import numpy as np
										import matplotlib.pyplot as plt
										import pandas as pd

										# Importing the dataset
										dataset = pd.read_csv('Breast cancer data.csv')
										X = dataset.iloc[:, :-1].values
										y = dataset.iloc[:, -1].values

										#Splitting the dataset into the Training set and Test set
										from sklearn.model_selection import train_test_split
										X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 0)

										# Feature Scaling
										from sklearn.preprocessing import StandardScaler
										sc = StandardScaler()
										X_train = sc.fit_transform(X_train)
										X_test = sc.transform(X_test)

										# Training Model on the Training set
										from sklearn.tree import DecisionTreeClassifier
										classifier = DecisionTreeClassifier(criterion = 'entropy', random_state = 0)
										classifier.fit(X_train, y_train)

										Evaluating using confusion matrix
										from sklearn.metrics import confusion_matrix, accuracy_score
										y_pred = classifier.predict(X_test)
										cm = confusion_matrix(y_test, y_pred)
										print(cm)
										accuracy_score(y_test, y_pred)

										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/Breast_logR.png" 
													alt="Logistic Regression visualization for breast cancer classification"
													class="gallery-trigger"
													data-gallery="breast-cancer"
													data-caption="Logistic Regression Model - Breast Cancer">
												<figcaption><strong>Figure 1</strong> Logistic Regression</figcaption>
											</figure>

											<figure>
												<img src="images/Breast_svm.png" 
													alt="Support Vector Machine visualization for breast cancer classification"
													class="gallery-trigger"
													data-gallery="breast-cancer"
													data-caption="SVM Model - Breast Cancer">
												<figcaption><strong>Figure 2</strong> SVM</figcaption>
											</figure>

											<figure>
												<img src="images/Breast_ksvm.png" 
													alt="Kernel SVM visualization for breast cancer classification"
													class="gallery-trigger"
													data-gallery="breast-cancer"
													data-caption="Kernel SVM Model - Breast Cancer">
												<figcaption><strong>Figure 3</strong> Kernel SVM</figcaption>
											</figure>

											<figure>
												<img src="images/Breast_knn.png" 
													alt="K-Nearest Neighbors visualization for breast cancer classification"
													class="gallery-trigger"
													data-gallery="breast-cancer"
													data-caption="K-Nearest Neighbors Model - Breast Cancer">
												<figcaption><strong>Figure 4</strong> K-Nearest Neighbor</figcaption>
											</figure>
											
											<figure>
												<img src="images/Breast_naive.png" 
													alt="Na√Øve Bayes visualization for breast cancer classification"
													class="gallery-trigger"
													data-gallery="breast-cancer"
													data-caption="Na√Øve Bayes Model - Breast Cancer">
												<figcaption><strong>Figure 5</strong> Na√Øve Bayes</figcaption>
											</figure>

											<figure>
												<img src="images/Breast_randfor.png" 
													alt="Random Forest visualization for breast cancer classification"
													class="gallery-trigger"
													data-gallery="breast-cancer"
													data-caption="Random Forest Model - Breast Cancer">
												<figcaption><strong>Figure 6</strong> Random Forest</figcaption>
											</figure>
											
											<figure>
												<img src="images/Breast_decision.png" 
													alt="Decision Tree visualization for breast cancer classification"
													class="gallery-trigger"
													data-gallery="breast-cancer"
													data-caption="Decision Tree Model - Breast Cancer">
												<figcaption><strong>Figure 7</strong> Decision Tree</figcaption>
											</figure>
										</div>


										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>Multiple algorithms provided different approaches to cancer classification, each with unique strengths for medical diagnosis</li>
											<li>Feature standardization proved crucial for distance-based algorithms (SVM, KNN) due to varying scales of cellular measurements</li>
											<li>Confusion matrix analysis revealed the trade-offs between sensitivity (detecting cancer) and specificity (avoiding false alarms)</li>
											<li>Model comparison enabled selection of the most reliable algorithm for medical diagnostic support</li>
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											Working with medical diagnostic data presented a critical class imbalance consideration that required careful attention to evaluation metrics beyond simple accuracy. While accuracy score provides an overall performance measure, it can be misleading in medical contexts where false negatives (missing actual cancer cases) have far more severe consequences than false positives (flagging benign cases as suspicious). The challenge was ensuring that model evaluation properly weighted the clinical importance of sensitivity (recall) versus specificity, as a model with 95% accuracy might still miss 20% of actual cancer cases if the dataset is imbalanced. This was addressed by implementing confusion matrix analysis to examine true positives, false positives, true negatives, and false negatives separately, enabling assessment of each model's ability to minimize the most clinically dangerous errors while maintaining overall diagnostic reliability.
										</p>
										<p><a href="https://github.com/tendai-codes/Machine-learning" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,Machine Learning">
										<h3>üìΩÔ∏è <strong> Bank Customer Segmentation </strong></h3>
										<p>
											Analyzed bank customer data to segment customers using K-Means Clustering, with dimensionality reduction achieved through PCA. This approach resulted in 7 well-defined customer segments based on key financial behaviors, optimizing the bank's ability to market tailored products and services to their customers.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development and comparison</li>
											<li><strong>Scikit-learn</strong> for Clustering (KMeans) and PCA</li>
											<li><strong>Pandas</strong> for data manipulation</li>
											<li><strong>Seaborn</strong> for for data visualisation</li>
											<li><strong>Matplotlib</strong> for data visualisation and model performance analysis</li>
											
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Load & inspect data:</strong> Loaded the dataset using <code>pd.read_csv()</code>, checked for nulls and reviewed data types using <code>.info()</code> and <code>.describe()</code>. </li>
											<li><strong>Exploratory Analysis:</strong> Removed customer ID column. Handled missing values, especially in <code>MINIMUM_PAYMENTS</code> and <code>CREDIT_LIMIT</code>. Used pair plots and distribution plots to understand feature distributions and detect outliers. </li>
											<li><strong>Feature selection & scaling:</strong> Selected numerical columns (like Age, Income, Spending Score) and scaled them using <code>StandardScaler</code> for optimal clustering.</li>
											<li><strong>Clustering wiht KMeans:</strong> Applied the Elbow Method to determine the optimal number of clusters and used <code>KMeans</code> to group customers.</li>
											<li><strong>Visualisation:</strong> Plotted clusters using PCA components. Created scatter plots with cluster labels to visualise customer groupings based on income and spending behaviour.</li>
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing the libraries
										credit_card_df = pd.read_csv('/content/4.+Marketing_data.csv')
										credit_card_df.info()

										credit_card_df.describe() (Table 1)

										- Mean balance is $1564
										- Balance frequency is frequently updated on average ~0.9, Purchases average is $1000, one off purchase average is ~$600
										- Average purchases frequency is around 0.5, Average ONEOFF_PURCHASES_FREQUENCY, PURCHASES_INSTALLMENTS_FREQUENCY, and CASH_ADVANCE_FREQUENCY are generally low
										- Average credit limit ~ 4500, Percent of full payment is 15%, Average tenure is 11 years
										
										# Check for missing data (Table 2)
										credit_card_df.isnull().sum()

										# Replace the missing elements with mean of the 'MINIMUM_PAYMENT'
										credit_card_df.MINIMUM_PAYMENTS.fillna(credit_card_df.MINIMUM_PAYMENTS.mean(), inplace=True)

										# Replace the missing elements with mean of the 'CREDIT_LIMIT'
										credit_card_df.CREDIT_LIMIT.fillna(credit_card_df.CREDIT_LIMIT.mean(), inplace=True)

										# Plot to check for missing data (Figure 1)
										sns.heatmap(credit_card_df.isnull(), yticklabels = False, cbar = False, cmap='Reds')
										
										# Check for duplicate entries
										credit_card_df.duplicated().sum()

										# Remove Customer ID
										credit_card_df.drop('CUST_ID', axis=1, inplace=True)

										# Define function to create subplots of distplots with KDE for all columns.

										def dist_plots(dataframe):
										fig, ax = plt.subplots(nrows=7, ncols=2, figsize=(15,30))
										index = 0
										for row in range(7):
											for col in range(2):
											sns.distplot(dataframe.iloc[:, index], ax=ax[row][col], kde_kws={'color':'blue', 'lw':3, 'label':'KDE'}, hist_kws= {'histtype':'step', 'lw':3, 'color':'green'})
											index += 1
										plt.tight_layout()
										plt.show()

										# Visualise distplots (Figure 2)
										dist_plots(credit_card_df)
										
										- 'Balance_Frequency' for most customers is updated frequently ~1, For 'PURCHASES_FREQUENCY', there are two distinct group of customers
										- For 'ONEOFF_PURCHASES_FREQUENCY' and 'PURCHASES_INSTALLMENT_FREQUENCY' most users don't do one off puchases or installment purchases frequently, Very small number of customers pay their balance in full 'PRC_FULL_PAYMENT'~0
										- Mean of balance is $1500, Credit limit average is around $4500, Most customers are ~11 years tenure
										
										# Heatmap to visaulise correlations (Figure 3)
										correlations = credit_card_df.corr()
										plt.figure(figsize=(20,20))
										sns.heatmap(correlations, annot=True)

										- 'PURCHASES' have high correlation between one-off purchases, 'installment purchases, purchase transactions, credit limit and payments.
										- Strong Positive Correlation between 'PURCHASES_FREQUENCY' and 'PURCHASES_INSTALLMENT_FREQUENCY'

										# Training Model on the Training set
										from sklearn.tree import DecisionTreeClassifier
										classifier = DecisionTreeClassifier(criterion = 'entropy', random_state = 0)
										classifier.fit(X_train, y_train)

										# Evaluating using confusion matrix
										from sklearn.metrics import confusion_matrix, accuracy_score
										y_pred = classifier.predict(X_test)
										cm = confusion_matrix(y_test, y_pred)
										print(cm)
										accuracy_score(y_test, y_pred)

										# Use Elbow Method to find optimal No of clusters (Figure 4)
										credit_card_df.head()

										# Apply Feature scaling
										scaler = StandardScaler()
										credit_card_df_scaled = scaler.fit_transform(credit_card_df)

										credit_card_df_scaled

										# Apply Elbow Method
										wcss = []
										for i in range(1, 20):
											kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)
											kmeans.fit(credit_card_df_scaled)
											wcss.append(kmeans.inertia_)
										plt.plot(range(1, 20), wcss, 'bx-')
										plt.title('The Elbow Method')
										plt.xlabel('Number of clusters')
										plt.ylabel('Score (WCSS)')
										plt.show();

										# Train data using K-Means method 

										- We can observe that, 4th cluster seems to be forming the elbow of the curve. However, the values does not reduce linearly until 8th cluster. Let's choose the number of clusters to be 7.

										# Assuming 'kmeans' is your fitted KMeans model
										kmeans = KMeans(n_clusters=7, init= 'k-means++',random_state=42)
										kmeans.fit(credit_card_df_scaled)

										# Use Principal Compenent Analysis to reduce dimensionality
										pca = PCA(n_components=2)
										principalComp = pca.fit_transform(credit_card_df_scaled )
										principalComp

										# Create a dataframe with the two components
										pca_df = pd.DataFrame(data=principalComp, columns=['PCA1', 'PCA2'])
										pca_df

										# Concatenate the clusters labels to the dataframe (Table 3)
										pca_df = pd.concat([pca_df, pd.DataFrame({'cluster': labels})], axis=1)
										pca_df.head()

										# Visualise Clusters (Figure 5)
										plt.figure(figsize=(10, 10))
										ax = sns.scatterplot(x='PCA1', y='PCA2', hue='cluster', data=pca_df, palette='tab10')
										plt.title('Clusters identified by PCA')
										plt.show()
										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/Bank Customer_df.png" 
													alt="Data frame showing bank customer characteristics"
													class="gallery-trigger"
													data-gallery="bank-customer"
													data-caption="Customer Data Overview">
												<figcaption><strong>Table 1</strong> Customer Data Frame</figcaption>
											</figure>

											<figure>
												<img src="images/Bank Customer_miss.png" 
													alt="Table showing missing data patterns in customer records"
													class="gallery-trigger"
													data-gallery="bank-customer"
													data-caption="Missing Data Analysis">
												<figcaption><strong>Table 2</strong> Missing Data Analysis</figcaption>
											</figure>

											<figure>
												<img src="images/Bank Customer_check missing.png" 
													alt="Visual confirmation of complete data after cleaning"
													class="gallery-trigger"
													data-gallery="bank-customer"
													data-caption="Data Completeness Verification">
												<figcaption><strong>Figure 1</strong> Data Completeness Verification</figcaption>
											</figure>

											<figure>
												<img src="images/Bank Customer_distplots.png" 
													alt="Distribution plots of customer attributes"
													class="gallery-trigger"
													data-gallery="bank-customer"
													data-caption="Feature Distribution Analysis">
												<figcaption><strong>Figure 2</strong> Feature Distribution Analysis</figcaption>
											</figure>
											
											<figure>
												<img src="images/Bank Customer_heat.png" 
													alt="Heatmap showing correlations between features"
													class="gallery-trigger"
													data-gallery="bank-customer"
													data-caption="Feature Correlation Heatmap">
												<figcaption><strong>Figure 3</strong> Feature Correlation Heatmap</figcaption>
											</figure>

											<figure>
												<img src="images/Bank Customer_elbow.png" 
													alt="Elbow method plot for optimal cluster determination"
													class="gallery-trigger"
													data-gallery="bank-customer"
													data-caption="Optimal Cluster Determination">
												<figcaption><strong>Figure 4</strong> Optimal Cluster Determination</figcaption>
											</figure>
											
											<figure>
												<img src="images/Bank Customer_table 3.png" 
													alt="Principal Component Analysis results table"
													class="gallery-trigger"
													data-gallery="bank-customer"
													data-caption="PCA Component Analysis">
												<figcaption><strong>Table 3</strong> PCA Component Analysis</figcaption>
											</figure>
											
											<figure>
												<img src="images/bank customers clusters.png" 
													alt="Visualization of bank customer clusters"
													class="gallery-trigger"
													data-gallery="bank-customer"
													data-caption="Customer Cluster Visualization">
												<figcaption><strong>Figure 5</strong> Customer Cluster Visualization</figcaption>
											</figure>
										</div>

										<h4>üåü <strong>Key Insights:</strong></h4> #fill
										<ul>
											<li>High income earners tend to be low spenders and Low income earners tend to be high spenders</li>
											<li>Customer spending behaviour is strongly differentiated by frequency of purchases and reliance on cash advances. Some customer groups showed heavy instalment purchases but minimal one-off spending, revealing clear segmentation potential for tailored credit card offers.</li>
										
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4> #fill
										<p>
											Initial visualisations of K-Means clusters were ambiguous due to the high dimensionality of features. Reducing dimensions with PCA made it easier to see meaningful separation, but it required balancing between retaining variance and simplifying complexity. I resolved this by examining explained variance ratios and adjusting the number of components accordingly.
										</p>
										<p><a href="https://github.com/tendai-codes/Machine-learning" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,Machine Learning,Tensorflow">
										<h3>üìΩÔ∏è <strong>Stock Price Analsysis using Ridge Regression </strong></h3>
										<p>
											This project focused on predicting future stock prices using historical data and Ridge Regression, comparing its performance to other models. I used Python and integrated both traditional machine learning and visualisation libraries to explore the data and build predictive models. Achieved an R-squared score of 98%, with a k-fold cross-validation score of 86%.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development and comparison</li>
											<li><strong>Scikit-learn</strong> for rideg regression model and evaluation and evaluation metrics</li>
											<li><strong>Pandas</strong> for dataset loading and initial data exploration</li>
											<li><strong>Matplotlib</strong> for data visualisationsand model performance analysis</li>
											<li><strong>NumPy</strong> for numerical operations and grid generation</li>
											<li><strong>Matplotlib</strong> for static visualisations</li>
											<li><strong>Plotly</strong> for interactive charts and dashboards</li>
											<li><strong>TensorFlow/Keras</strong> for for experimenting with neural models</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Load & inspect data:</strong> Loaded historical stock price and volume data from CSV files. Visualised trends in stock prices and volumes using line and distribution plots. </li>
											<li><strong>Preprocessing:</strong> Cleaned and aligned datasets by timestampse. Normalised features and created lag-based features for time series modelling.</li>
											<li><strong>Model Development:</strong> Applied Ridge Regression to reduce overfitting from correlated features. Split dataset into training and testing sets using <code>train_test_split().</code></li>
											<li><strong>Performance comparison:</strong> Evaluated models using <code>r2_score</code>.</li>
											<li><strong>Visualisation:</strong> Plotted predicted vs actual stock prices to interpret model behaviour.</li>
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing the libraries
										import pandas as pd
										import plotly.express as px
										from copy import copy
										from scipy import stats
										import matplotlib.pyplot as plt
										import numpy as np
										import plotly.figure_factory as ff
										from sklearn.linear_model import LinearRegression
										from sklearn.svm import SVR
										from sklearn.model_selection import train_test_split
										from sklearn.metrics import r2_score

										# Get stock prices dataframe info
										stock_price_df.info()

										# Get stock volume dataframe info
										stock_vol_df.info()

										stock_vol_df.describe()

										# Function to normalize stock prices based on their initial price (Figure 1)
										def normalize(df):
										x = df.copy()
										for i in x.columns[1:]:
											x[i] = x[i]/x[i][0]
										return x

										# Function to plot interactive plots using Plotly Express (Figure 2)
										def interactive_plot(df, title):
										fig = px.line(title = title)
										for i in df.columns[1:]:
											fig.add_scatter(x = df['Date'], y = df[i], name = i)
										fig.show()

										# Interactive chart for stocks Prices data (Figure 1)
										interactive_plot(stock_price_df, 'Stock Prices')

										# Normalised chart for stocks Prices data (Figure 2)
										interactive_plot(normalize(stock_price_df), 'Normalized Prices')

										# Interactive chart for stocks Volume data (Figure 3)
										interactive_plot(stock_vol_df, 'Stocks Volume')

										# Normalised chart for stocks volume data (Figure 4)
										interactive_plot(normalize(stock_vol_df), 'Normalized Volume')

										# Prepare Data before training Regression model

										# Function to concatenate the date, stock price, and volume in one dataframe
										def individual_stock(price_df, vol_df, name):
											return pd.DataFrame({'Date': price_df['Date'], 'Close': price_df[name], 'Volume': vol_df[name]})

										# Function to return the output (target) data ML Model [Target stock price today will be tomorrow's price]

										def trading_window(data):

										n = 1 #1 day window

										# Create a column containing the prices for the next 1 days
										data['Target'] = data[['Close']].shift(-n)

										return data

										# Test concatenation function using individual stock
										price_volume_df = individual_stock(stock_price_df, stock_vol_df, 'AAPL')
										price_volume_df

										# Function to return the output (target) data ML Model [Target stock price today will be tomorrow's price]
										
										def trading_window(data):

										n = 1 #1 day window

										# Create a column containing the prices for the next 1 days
										data['Target'] = data[['Close']].shift(-n)

										return data

										# Test concatenation function using individual stock
										price_volume_df = individual_stock(stock_price_df, stock_vol_df, 'AAPL')
										price_volume_df

										# Test trading window function using concatenated df (Table 1)
										price_volume_target_df = trading_window(price_volume_df)
										price_volume_target_df

										# Apply Feature Scaling to data
										from sklearn.preprocessing import MinMaxScaler
										sc = MinMaxScaler(feature_range = (0, 1))
										price_volume_target_scaled_df = sc.fit_transform(price_volume_target_df.drop(columns = ['Date']))

										# Creating Feature and Target
										X = price_volume_target_scaled_df[:,:2]
										y = price_volume_target_scaled_df[:,2:]

										# Converting dataframe to arrays
										X = np.asarray(X)
										y = np.asarray(y)
										X.shape, y.shape

										# Spliting the data this way, since order is important in time-series
										split = int(0.80 * len(X))
										X_train = X[:split]
										y_train = y[:split]
										X_test = X[split:]
										y_test = y[split:]

										# Define a data plotting function (Figue 5)
										def show_plot(data, title):
										plt.figure(figsize = (13, 5))
										plt.plot(data, linewidth = 3)
										plt.title(title)
										plt.grid()
										plt.legend(['X_train', 'X_test'])

										show_plot(X_train, 'Training Data for AAPL stock')
										show_plot(X_test, 'Testing Data for AAPL stock')

										# Build & Train Ridge Regression model
										- This model was chosen to get a generalised trend for data (avoids over fitting) - expected low testing accuracy expected. Note that Ridge regression performs linear least squares with L2 regularization.

										from sklearn.linear_model import Ridge
										regression_model = Ridge()
										regression_model.fit(X_train, y_train)

										# Test the model and calculate its accuracy
										ridge_accuracy = regression_model.score(X_test, y_test)
										print("Ridge Regression Score: ", ridge_accuracy)

										# K-Fold Cross validation Score
										from sklearn.model_selection import cross_val_score
										accuracies = cross_val_score(estimator = regression_model, X = X_train, y = y_train, cv = 10)
										print("Accuracy: {:.2f} %".format(accuracies.mean()*100))
										print("Standard Deviation: {:.2f} %".format(accuracies.std()*100))

										Accuracy: 86.27%
										Standard Deviation: 11.01 %

										# Append the predicted values into a list
										predicted = []
										for i in predicted_prices:
										predicted.append(i[0])

										# Append the close values to the list
										close = []
										for i in price_volume_target_scaled_df:
											close.append(i[0])

										# Create a dataframe based on the dates in the individual stock data
										df_predicted = price_volume_target_df[['Date']]
										df_predicted

										# Function to add the close and predicted values to the dataframe
										def add_predicted_and_close(df, close, predicted):
										df_predicted['Close'] = close
										df_predicted['Prediction'] = predicted
										return df_predicted

										add_predicted_and_close(df_predicted, close, predicted) (Table 2)

										# Define interactive plot (Figure 6 & 7)

										def interactive_plot(df, title):
										fig = px.line(df, title = title, x='Date', y=['Close', 'Prediction'])

										fig.show()

										# Plot the results
										interactive_plot(df_predicted, "Original Vs. Prediction (alpha=1)")


										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/Ridge_stock price.png" 
													alt="Stock price visualization"
													class="gallery-trigger"
													data-gallery="ridge-regression"
													data-caption="Stock Prices">
												<figcaption><strong>Figure 1</strong> Stock Prices</figcaption>
											</figure>

											<figure>
												<img src="images/Ridge_stock price_norm.png" 
													alt="Normalized stock price visualization"
													class="gallery-trigger"
													data-gallery="ridge-regression"
													data-caption="Stock Prices - Normalised">
												<figcaption><strong>Figure 2</strong> Stock Prices - Normalised</figcaption>
											</figure>

											<figure>
												<img src="images/Ridge_stock vol.png" 
													alt="Stock trading volume visualization"
													class="gallery-trigger"
													data-gallery="ridge-regression"
													data-caption="Stock Volumes">
												<figcaption><strong>Figure 3</strong> Stock Volumes</figcaption>
											</figure>

											<figure>
												<img src="images/Ridge_stock vol_norm.png" 
													alt="Normalized stock trading volume visualization"
													class="gallery-trigger"
													data-gallery="ridge-regression"
													data-caption="Stock Volumes - Normalised">
												<figcaption><strong>Figure 4</strong> Stock Volumes - Normalised</figcaption>
											</figure>

											<figure>
												<img src="images/Ridge_table 1.png" 
													alt="Price and volume data table"
													class="gallery-trigger"
													data-gallery="ridge-regression"
													data-caption="Price Volume Data">
												<figcaption><strong>Table 1</strong> Price Volume Data</figcaption>
											</figure>

											<figure>
												<img src="images/Ridge_Figure 5.png" 
													alt="Training and test data comparison"
													class="gallery-trigger"
													data-gallery="ridge-regression"
													data-caption="Training & Test Data">
												<figcaption><strong>Figure 5</strong> Training & Test Data</figcaption>
											</figure>
											
											<figure>
												<img src="images/Ridge_table 2.png" 
													alt="Closing and predicted values table"
													class="gallery-trigger"
													data-gallery="ridge-regression"
													data-caption="Closing & Predicted Values">
												<figcaption><strong>Table 2</strong> Closing & Predicted Values</figcaption>
											</figure>

											<figure>
												<img src="images/Ridge_Figure 6.png" 
													alt="Random Forest model results"
													class="gallery-trigger"
													data-gallery="ridge-regression"
													data-caption="Random Forest Analysis">
												<figcaption><strong>Figure 6</strong> Random Forest Analysis</figcaption>
											</figure>
											
											<figure>
												<img src="images/Ridge_Figure 7.png" 
													alt="Decision Tree model results"
													class="gallery-trigger"
													data-gallery="ridge-regression"
													data-caption="Decision Tree Analysis">
												<figcaption><strong>Figure 7</strong> Decision Tree Analysis</figcaption>
											</figure>
										</div>

										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>Ridge Regression outperformed Linear Regression in terms of stability and generalisation, especially when features had multicollinearity. The regularisation strength helped in handling noisy financial indicators. </li>
											
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											Feature engineering for time series prediction was a significant challenge. Initially, using raw historical prices didn‚Äôt yield strong predictive accuracy. After adding lagged variables and scaling features, the model performance improved. It required careful experimentation to balance information richness and model simplicity.
										</p>
										<p><a href="https://github.com/tendai-codes/Machine-learning" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,TensorFlow,Deep Learning">
										<h3>üìΩÔ∏è <strong> Stock Price Analysis using Long Short Term Memory Neural Network </strong></h3>
										<p>
											This project focused on predicting Tesla (TSLA) stock prices using deep learning techniques with LSTM neural networks. I built a time series forecasting model that uses historical closing prices and trading volumes to predict next-day stock prices, implementing robust validation through K-fold cross-validation.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development and comparison</li>
											<li><strong>Scikit-learn</strong> for data scaling, train-test splits, and cross-validations</li>
											<li><strong>NumPy</strong> for numerical operations and grid generation</li>
											<li><strong>Pandas</strong> for dataset loading and initial data exploration</li>
											<li><strong>Matplotlib</strong> for data visualisations and model performance analysis</li>
											<li><strong>TensorFlow/Keras</strong> for building and training LSTM neural networks</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Data Preparation:</strong> Combined separate stock price and volume datasets using custom <code>individual_stock()</code> function. Created target variable using <code>trading_window()</code> function with 1-day prediction horizon. Focused on Tesla (TSLA) stock as the primary case study.</li>
											<li><strong>Feature Engineering & Preprocessing:</strong> Applied <code>MinMaxScaler</code> to normalize closing prices and volumes to (0,1) range. Converted 1D arrays to 3D format required for LSTM input (samples, timesteps, features). Split data with 75% for training and 25% for testing.</li>
											<li><strong>Model Architecture:</strong> Built multi-layer LSTM model with three LSTM layers (150 units each). Implemented dropout layers (0.3 rate) between LSTM layers to prevent overfitting, used linear activation for final dense layer to output continuous price predictions and compiled with Adam optimizer and MSE loss function.</li>
											<li><strong>Model Validation:</strong> Implemented 5-fold cross-validation to ensure model robustness, trained for 20 epochs with batch size of 32 and used 20% validation split during training for monitoring.</li>
											
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing the libraries
										import pandas as pd
										import plotly.express as px
										from copy import copy
										from scipy import stats
										import matplotlib.pyplot as plt
										import numpy as np
										import plotly.figure_factory as ff
										from sklearn.linear_model import LinearRegression
										from sklearn.svm import SVR
										from sklearn.model_selection import train_test_split
										from sklearn.metrics import r2_score
										from tensorflow import keras

										# Prepare Data for training

										# Function to concatenate the date, stock price, and volume in one dataframe
										def individual_stock(price_df, vol_df, name):
											return pd.DataFrame({'Date': price_df['Date'], 'Close': price_df[name], 'Volume': vol_df[name]})

										# Function to return the output (target) data ML Model [Target stock price today will be tomorrow's price]

										def trading_window(data):

										n = 1 #1 day window

										# Create a column containing the prices for the next 1 days
										data['Target'] = data[['Close']].shift(-n)

										return data

										# Test concatenation function using individual stock (Table 1)
										price_volume_df = individual_stock(stock_price_df, stock_vol_df, 'TSLA')
										price_volume_df

										# Train An LSTM Time Series Model

										# Use the close and volume data as training data (Input)
										training_data = price_volume_df.iloc[:, 1:3].values
										training_data

										# Apply feature scaling the data
										from sklearn.preprocessing import MinMaxScaler
										sc = MinMaxScaler(feature_range = (0, 1))
										training_set_scaled = sc.fit_transform(training_data)

										# Create the training and testing data, training data contains present day and previous day values
										X = []
										y = []
										for i in range(1, len(price_volume_df)):
											X.append(training_set_scaled [i-1:i, 0])
											y.append(training_set_scaled [i, 0])

										# Convert the data into array format
										X = np.asarray(X)
										y = np.asarray(y)

										# Split the data
										split = int(0.75 * len(X))
										X_train = X[:split]
										y_train = y[:split]
										X_test = X[split:]
										y_test = y[split:]

										# Reshape the 1D arrays to 3D arrays to feed in the model
										X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))
										X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))
										X_train.shape, X_test.shape

										# Create the LSTM model (Table 1)
										inputs = keras.layers.Input(shape=(X_train.shape[1], X_train.shape[2]))
										x = keras.layers.LSTM(150, return_sequences= True)(inputs)
										x = keras.layers.Dropout(0.3)(x)

										x = keras.layers.LSTM(150, return_sequences=True)(x)
										x = keras.layers.Dropout(0.3)(x)

										x = keras.layers.LSTM(150)(x)
										outputs = keras.layers.Dense(1, activation='linear')(x)

										model = keras.Model(inputs=inputs, outputs=outputs)
										model.compile(optimizer='adam', loss="mse")
										model.summary()

										# Train the model
										history = model.fit(
											X_train, y_train,
											epochs = 20,
											batch_size = 32,
											validation_split = 0.2)

										# K folds cross validation for model

										from sklearn.model_selection import KFold

										# Define the number of folds
										k = 5
										kf = KFold(n_splits=k, shuffle=True)

										# Initialize a list to store the validation loss for each fold
										fold_losses = []

										for train_index, val_index in kf.split(X):
										X_train_fold, X_val_fold = X[train_index], X[val_index]
										y_train_fold, y_val_fold = y[train_index], y[val_index]

										# Reshape data for LSTM
										X_train_fold = np.reshape(X_train_fold, (X_train_fold.shape[0], X_train_fold.shape[1], 1))
										X_val_fold = np.reshape(X_val_fold, (X_val_fold.shape[0], X_val_fold.shape[1], 1))

										# Train the model on the training fold
										history = model.fit(
											X_train_fold, y_train_fold,
											epochs=20,
											batch_size=32,
											validation_data=(X_val_fold, y_val_fold)	)

										# Evaluate the model on the validation fold and store the loss
										val_loss = model.evaluate(X_val_fold, y_val_fold)
										fold_losses.append(val_loss)

										# Calculate the average validation loss across all folds
										average_val_loss = np.mean(fold_losses)
										print("Average Validation Loss:", average_val_loss)

										# Get the Closing price data
										close = []
										for i in training_set_scaled:
										close.append(i[0])

										# Create dataframe for the dates, predicted prices and closing price
										df_predicted = price_volume_df[1:][['Date']]
										df_predicted['Predictions'] = test_predicted
										df_predicted['Close'] = close[1:]
										df_predicted

										# Define interactive plot

										def interactive_plot(df, title):
										fig = px.line(df, title = title, x='Date', y=['Close', 'Predictions'])

										fig.show()

										# Plot the results (Figure 1 & 2)
										interactive_plot(df_predicted, "Original Vs. Prediction (TSLA)")

										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/LSTM_table 1.png" 
													alt="Table 1: closing vol Df"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 1: closing vol Df">
												<figcaption><strong>Table 1</strong></figcaption>
											</figure>

											<figure>
												<img src="images/LSTM_table 2.png" 
													alt="Table 2: LSTM Model Execution"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 2: LSTM Model Execution">
												<figcaption><strong>Table 2</strong> LSTM Model Execution</figcaption>
											</figure>

											<figure>
												<img src="images/LSTM_table 3.png" 
													alt="Table 3: Closing vs Prediction Price"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 3: Closing vs Prediction Price">
												<figcaption><strong>Table 3</strong> Closing vs Prediction Price</figcaption>
											</figure>

											<figure>
												<img src="images/LSTM_fig 1.png" 
													alt="Figure 1: Closing Price"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Figure 1: Closing Price">
												<figcaption><strong>Figure 1</strong> Closing Price</figcaption>
											</figure>
											
											<figure>
												<img src="images/LSTM_fig 2.png" 
													alt="Figure 2: Closing vs Prediction Price"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Figure 2: Closing vs Prediction Price">
												<figcaption><strong>Figure 2</strong> Closing vs Prediction Price</figcaption>
											</figure>
										</div>


										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>The model demonstrated strong performance in predicting stock prices, with an average validation loss indicating effective learning.</li>
											<li>Release day (or time) significantly influenced stock price trends, reflecting market behavior that could be strategic or influenced by external factors.</li>
											<li>Using LSTM allowed the model to capture temporal dependencies effectively, which might not have been possible with simpler models like linear regression.</li>
											<li>K-fold cross-validation revealed consistent model performance across different time periods, suggesting the LSTM approach generalizes well to unseen Tesla stock data.</li>
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											My biggest challenge was preparing the time series data in the correct 3D format for LSTM input. Initially, I struggled with reshaping arrays from 1D to the required (samples, timesteps, features) structure. After researching LSTM input requirements and experimenting with NumPy reshape operations, I learned to properly sequence the data with sliding windows and convert to the appropriate tensor dimensions for neural network training.
										<p><a href="https://github.com/tendai-codes/Machine-learning" class="github-button" target="_blank">View on GitHub</a></p>
									</section>

									<section class="project-item" data-tags="Python,Deep Learning,TensorFlow">
										<h3>üìΩÔ∏è <strong>Customer Churn Prediction with ANN (Classification) </strong></h3>
										<p>
											This project developed a binary classification model to predict bank customer churn using an Artificial Neural Network (ANN). I built a deep learning solution to identify customers likely to leave the bank based on their demographic and account information, enabling proactive retention strategies.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development and comparison</li>
											<li><strong>Scikit-learn</strong> for preprocessing, encoding, scaling, and evaluation metrics</li>
											<li><strong>Pandas</strong> for dataset loading and initial data exploration</li>
											<li><strong>NumPy</strong> for numerical operations and grid generation</li>
											<li><strong>TensorFlow/Keras</strong> for building and training the neural network</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Load & inspect data:</strong> Loaded customer banking dataset with demographic and account features, selected relevant features <code>(columns [:, 3:-1])</code> as input variables and extracted churn status as target binary variable<code>loc[]</code>. </li>
											<li><strong>Data preprocessing Analysis:</strong> Applied <code>Label Encoding</code> to convert Gender column to numerical format, Implemented <code>One-Hot Encoding</code> for Geography column to handle multiple categories and used <code>ColumnTransformer</code> to apply different encodings to specific columns</li>
											<li><strong>Model Architecture:</strong> Built <code>Sequential</code> ANN with three layers: two hidden layers (6 units each, <code>ReLU activation</code>) and output layer (1 unit, <code>sigmoid activation</code>), compiled with <code>Adam optimizer</code> and <code>binary crossentropy</code> loss for binary classification and trained for 100 epochs with batch size of 32</li>
											<li><strong>Model Evaluation:</strong> Generated predictions on test set with 0.5 probability threshold, created confusion matrix to analyze true/false positives and negatives and calculated accuracy score for overall model performance assessment</li>
											
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing the libraries
										import numpy as np
										import pandas as pd
										import tensorflow as tf

										# Import dataset
										dataset = pd.read_csv('Churn_Modelling.csv')
										X = dataset.iloc[:, 3:-1].values
										y = dataset.iloc[:, -1].values

										print(X) (Table 1)
										print(y) (Table 2)

										# Encoding categorical data (encoding gender column) (Table 3)
										from sklearn.preprocessing import LabelEncoder
										le = LabelEncoder()
										X[:, 2] = le.fit_transform(X[:, 2])

										print(X)

										# Encoding categorical data (One Hot encoding geography column) (Table 4)
										from sklearn.compose import ColumnTransformer
										from sklearn.preprocessing import OneHotEncoder
										ct = ColumnTransformer(transformers=[('encoder', OneHotEncoder(), [1])], remainder='passthrough')
										X = np.array(ct.fit_transform(X))

										print(X)

										# Splitting the dataset into Training and test set
										from sklearn.model_selection import train_test_split
										X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

										# Feature Scaling
										from sklearn.preprocessing import StandardScaler
										sc = StandardScaler()
										X_train = sc.fit_transform(X_train)
										X_test = sc.transform(X_test)

										# Building ANN
										ann = tf.keras.models.Sequential()
										ann.add(tf.keras.layers.Dense(units=6, activation='relu'))
										ann.add(tf.keras.layers.Dense(units=6, activation='relu'))
										ann.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))

										# Compiling the ANN
										ann.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])

										# Training ANN (Table 5)
										ann.fit(X_train, y_train, batch_size = 32, epochs = 100)

										# Predicting results of a single observation
										print(ann.predict(sc.transform([[1, 0, 0, 600, 1, 40, 3, 60000, 2, 1, 1, 50000]])) > 0.5)

										# Predicting Test set results (Table 6)
										y_pred = ann.predict(X_test)
										y_pred = (y_pred > 0.5)
										print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))

										# Making the Confusion Matrix (Table 7)

										from sklearn.metrics import confusion_matrix, accuracy_score
										cm = confusion_matrix(y_test, y_pred)
										print(cm)
										accuracy_score(y_test, y_pred)

										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/ANNClass_table 1.png" 
													alt="Table 1: Breast_logR"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 1: Breast_logR">
												<figcaption><strong>Table 1</strong> Variable X</figcaption>
											</figure>

											<figure>
												<img src="images/ANNClass_table 2.png" 
													alt="Table 2: Breast_svm"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 2: Breast_svm">
												<figcaption><strong>Table 2</strong> Variable y</figcaption>
											</figure>

											<figure>
												<img src="images/ANNClass_table 3.png" 
													alt="Table 3: Breast_ksvm"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 3: Breast_ksvm">
												<figcaption><strong>Table 3</strong> Encoding Gender</figcaption>
											</figure>

											<figure>
												<img src="images/ANNClass_table 4.png" 
													alt="Table 4: Breast_knn"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 4: Breast_knn">
												<figcaption><strong>Table 4</strong> Encoding Country</figcaption>
											</figure>
											
											<figure>
												<img src="images/ANNClass_table 5.png" 
													alt="Table 5: Breast_naive"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 5: Breast_naive">
												<figcaption><strong>Table 5</strong> Training the ANN</figcaption>
											</figure>

											<figure>
												<img src="images/ANNClass_table 6.png" 
													alt="Table 6: Breast_randfor"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 6: Breast_randfor">
												<figcaption><strong>Table 6</strong> Predicting Test set Results</figcaption>
											</figure>
											
											<figure>
												<img src="images/ANNClass_table 7.png" 
													alt="Table 7: Breast_decision"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 7: Breast_decision">
												<figcaption><strong>Table 7</strong> Confusion Matrix</figcaption>
											</figure>
										</div>


										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>Neural networks effectively capture non-linear relationships between customer demographics and churn behavior, outperforming traditional linear models for this complex classification task</li>
											<li>Feature engineering with proper encoding techniques significantly improved model performance, particularly the one-hot encoding of geography which revealed location-based churn patterns</li>
											<li>Confusion matrix analysis revealed the trade-offs between sensitivity (detecting cancer) and specificity (avoiding false alarms)</li>
											<li>Standardization was crucial for ANN convergence, as the varied scales of financial features (account balance, salary) required normalization to prevent training instability</li>
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											The main challenge was handling mixed categorical and numerical data types efficiently. Initially, I struggled with applying different encoding methods to different columns simultaneously. After experimenting with various approaches, I discovered ColumnTransformer, which allowed me to apply One-Hot Encoding to geography while preserving other numerical features, streamlining the preprocessing pipeline significantly.
										</p>
										
									</section>

									<section class="project-item" data-tags="Python,Deep Learning,TensorFlow">
										<h3>üìΩÔ∏è <strong>Power Plant Energy Output Prediction with ANN (Regression) </strong></h3>
										<p>
											This project explored publicly available data on top-grossing US films to identify patterns across genres, studios, and release schedules. I used <strong>R</strong> and <strong>ggplot2</strong> for data exploration and visualisation.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development and comparison</li>
											<li><strong>Scikit-learn</strong> for preprocessing, encoding, scaling, and evaluation metrics</li>
											<li><strong>Pandas</strong> for dataset loading and initial data exploration</li>
											<li><strong>NumPy</strong> for numerical operations and grid generation</li>
											<li><strong>TensorFlow/Keras</strong> for building and training the neural network</li>

										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Load & inspect data:</strong> Loaded Combined Cycle Power Plant dataset from Excel file containing hourly average ambient variables: <code>Ambient Temperature</code><strong>(AT)</strong>, <code>Ambient Pressure</code> <strong>(AP)</strong>, <code>Relative Humidity</code> <strong>(RH)</strong>, <code>Exhaust Vacuum</code> <strong>(V)</strong>, and <code>net hourly electrical energy output</code> <strong>(PE)</strong>. Extracted four environmental features as input variables: <strong>AT (¬∞C)</strong>, <strong>V (cm Hg)</strong>, <strong>AP (mbar)</strong>, and <strong>RH (%)</strong>. Used <strong>PE (MW)</strong> as continuous target variable representing net hourly electrical energy output for regression </li>
											<li><strong>Data Preparation:</strong> Split dataset into 80% training and 20% testing sets with random_state=0 for reproducibility, no feature scaling applied, relying on neural network's ability to learn appropriate feature weights and maintained original feature scales since all variables were in compatible ranges </li>
											<li><strong>Model Architecture:</strong> Built <code>Sequential</code> ANN with 4 layers: 3 hidden layers (6 units each, <code>ReLU activation</code>) and linear output layer (1 unit, <code>no activation</code>), compiled with <code>Adam optimizer</code> and <code>Mean Squared Error</code> loss for regression optimization</li>
											<li><strong>Model training & Evaluation:</strong> Trained for 100 epochs with batch size of 32 for stable gradient updates, generated predictions on test set without threshold conversion, and compared predicted vs actual energy outputs with 2-decimal precision formatting</li>
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing the libraries
										import numpy as np
										import pandas as pd
										import tensorflow as tf

										# Importing dataset
										dataset = pd.read_excel('Folds5x2_pp.xlsx')
										X = dataset.iloc[:, :-1].values
										y = dataset.iloc[:, -1].values

										# Splitting the dataset into the Training set and Test set

										from sklearn.model_selection import train_test_split
										X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

										# Building the ANN

										ann = tf.keras.models.Sequential()
										ann.add(tf.keras.layers.Dense(units=6, activation='relu'))
										ann.add(tf.keras.layers.Dense(units=6, activation='relu'))
										ann.add(tf.keras.layers.Dense(units=6, activation='relu'))
										ann.add(tf.keras.layers.Dense(units=1))

										# Compiling the ANN
										ann.compile(optimizer = 'adam', loss = 'mean_squared_error')

										# Training the ANN (Table 1)

										ann.fit(X_train, y_train, batch_size = 32, epochs = 100)

										# Predicting the results of the test set (Table 2)
										y_pred = ann.predict(X_test)
										np.set_printoptions(precision=2)
										print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))

										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/ANNReg_Table 1.png" 
													alt="Table 1: Training ANN"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 1: Training ANN">
												<figcaption><strong>Table 1</strong> Training ANN</figcaption>
											</figure>

											<figure>
												<img src="images/ANNReg_Table 2.png" 
													alt="Table 2: Predicting Test Set Results"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 2: Predicting Test Set Results">
												<figcaption><strong>Table 2</strong> Predicting Test Set Results</figcaption>
											</figure>

											<figure>
												<img src="images/ANNClass_table 3.png" 
													alt="Table 3: Breast_ksvm"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 3: Breast_ksvm">
												<figcaption><strong>Table 3</strong> Encoding Gender</figcaption>
											</figure>

											<figure>
												<img src="images/ANNClass_table 4.png" 
													alt="Table 4: Breast_knn"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 4: Breast_knn">
												<figcaption><strong>Table 4</strong> Encoding Country</figcaption>
											</figure>
										</div>


										<h4>üåü <strong>Key Insights:</strong></h4>
										<ul>
											<li>Deep neural networks excel at modeling complex thermodynamic relationships in combined cycle power plants, capturing non-linear interactions between ambient conditions (temperature, pressure, humidity, vacuum) and energy output that traditional linear models miss</li>
											<li>Regression ANN architecture with multiple hidden layers effectively learned the intricate dependencies between environmental variables and gas/steam turbine efficiency in the combined cycle system</li>
											<li>Mean Squared Error optimization provided robust training for continuous energy prediction, enabling accurate forecasting of net hourly electrical output (PE) across different seasonal and operational conditions</li>
										</ul>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											My primary challenge was determining the optimal network depth for regression without overfitting. Initially, I experimented with different numbers of hidden layers and found that too few layers couldn't capture the complex thermodynamic relationships, while too many layers led to overfitting. After testing various architectures, I settled on three hidden layers as the sweet spot that balanced model complexity with generalization performance.
										
									</section>

									<section class="project-item" data-tags="Python,Deep Learning,TensorFlow">
										<h3>üìΩÔ∏è <strong>Restaurant Review Sentiment Analysis with NLP </strong></h3>
										<p>
											In this project developed a natural language processing model to classify restaurant reviews as positive or negative sentiment using text preprocessing and machine learning. I built an end-to-end NLP pipeline that transforms raw review text into numerical features for binary sentiment classification using Naive Bayes algorithm.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											<li><strong>Python</strong> for machine learning model development and comparison</li>
											<li><strong>Scikit-learn</strong> for feature extraction <code>(CountVectorizer)</code>, model training (GaussianNB), and evaluation metrics</li>
											<li><strong>Pandas</strong> for dataset loading and initial data exploration</li>
											<li><strong>NumPy</strong> for numerical operations and grid generation</li>
											<li><strong>Regular Expressions (re)</strong> for text cleaning and preprocessing</li>
											<li><strong>NLTK</strong> for natural language processing, stopwords, and text stemming</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Text Preprocessing & Cleaning:</strong> Applied comprehensive text cleaning on 1000 restaurant reviews using regex to remove non-alphabetic characters, converted all text to lowercase for consistency and split into individual words, implemented Porter Stemming to reduce words to their root forms (e.g., "running" ‚Üí "run"), and removed English stopwords while preserving "not" to maintain negation context for sentiment analysis </li>
											<li><strong>Feature Engineering:</strong> Created Bag of Words model using CountVectorizer with maximum 1500 features to convert text to numerical representation, generated sparse matrix where each column represents a unique word and values indicate word frequency and extracted sentiment labels (positive/negative) as target variable for binary classification </li>
											<li><strong>Model training & Evaluation:</strong> Split dataset into 80% training and 20% testing sets with random_state=0, trained Gaussian Naive Bayes classifier on the bag-of-words features, generated predictions on test set and compared against actual sentiment labels and evaluated model performance using confusion matrix and accuracy score metrics</li>
											
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing the libraries
										import re
										import nltk
										nltk.download('stopwords')
										from nltk.corpus import stopwords
										from nltk.stem.porter import PorterStemmer
										corpus = []
										for i in range(0, 1000):
										review = re.sub('[^a-zA-Z]', ' ', dataset['Review'][i])
										review = review.lower()
										review = review.split()
										ps = PorterStemmer()
										all_stopwords = stopwords.words('english')
										all_stopwords.remove('not')
										review = [ps.stem(word) for word in review if not word in set(all_stopwords)]
										review = ' '.join(review)
										corpus.append(review)

										print(corpus) (Table 1)

										# Creating the bag of words model
										from sklearn.feature_extraction.text import CountVectorizer
										cv = CountVectorizer(max_features = 1500)
										X = cv.fit_transform(corpus).toarray()
										y = dataset.iloc[:, -1].values

										# Splitting the dataset into the Training set and Test set

										from sklearn.model_selection import train_test_split
										X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20, random_state = 0)

										# Training the Naive Bayes model on the Training set (Table 2)
										from sklearn.naive_bayes import GaussianNB
										classifier = GaussianNB()
										classifier.fit(X_train, y_train)

										# Predicting the Test set results (Table 3)
										y_pred = classifier.predict(X_test)
										print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))

										# Making Confusion Matrix (Table 4)
										from sklearn.metrics import confusion_matrix, accuracy_score
										cm = confusion_matrix(y_test, y_pred)
										print(cm)
										accuracy_score(y_test, y_pred)
										</code></pre>

										
										<!-- Visualisations -->

										<div class="image-gallery">
											<figure>
												<img src="images/NLP_table 1.png" 
													alt="Table 1: Removed words"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 1: Removed words">
												<figcaption><strong>Table 1</strong> Removed words</figcaption>
											</figure>

											<figure>
												<img src="images/NLP_table 2.png" 
													alt="Table 2: Naive Bayes Model"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 2: Naive Bayes Model">
												<figcaption><strong>Table 2</strong> Naive Bayes Model y</figcaption>
											</figure>

											<figure>
												<img src="images/NLP_table 3.png" 
													alt="Table 3: Predicting Test Set Results"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 3: Predicting Test Set Results">
												<figcaption><strong>Table 3</strong> Predicting Test Set Results </figcaption>
											</figure>

											<figure>
												<img src="images/NLP_table 4.png" 
													alt="Table 4: Confusion Matrix"
													class="gallery-trigger"
													data-gallery="project1"
													data-caption="Table 4: Confusion Matrix">
												<figcaption><strong>Table 4</strong> Confusion Matrix </figcaption>
											</figure>
										</div>


										<h4>üåü <strong>Key Insights:</strong></h4>
										<p>
											<li>Text preprocessing significantly impacts model performance, thus removing noise, stemming words, and strategic stopword removal (keeping "not") improved the classifier's ability to capture sentiment nuances</li>
											<li>The Bag of Words representation effectively captured sentiment patterns despite its simplicity, with the 1500 most frequent words providing sufficient discriminative power for restaurant review classification</li>
											<li>Mean Squared Error optimization provided robust training for continuous energy prediction, enabling accurate forecasting of net hourly electrical output (PE) across different seasonal and operational conditions</li>
										</p>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											The main challenge was balancing feature dimensionality with model performance. Initially, I used all unique words which created an extremely sparse and high-dimensional feature space, leading to overfitting. After experimenting with different max_features values in CountVectorizer, I found that limiting to 1500 features provided the optimal trade-off between capturing important sentiment words and maintaining computational efficiency while avoiding the curse of dimensionality.
										</p>
										
									</section>

									<section class="project-item" data-tags="Python,Deep Learning,TensorFlow">
										<h3>üìΩÔ∏è <strong>Cat vs Dog Image Classification with CNN </strong></h3>
										<p>
											developed a Convolutional Neural Network to classify images of cats and dogs using deep learning computer vision techniques. I built an end-to-end image classification pipeline that processes raw images through data augmentation, feature extraction, and binary classification to distinguish between cats and dogs with high accuracy.
										</p>

										<h4>üíª <strong>Tech Stack:</strong></h4>
										<ul>
											
											<li><strong>ImageDataGenerator</strong> for real-time data augmentation and preprocessing</li>
											<li><strong>NumPy</strong>  for array manipulation and image processing</li>
											<li><strong>TensorFlow/Keras</strong> for building and training convolutional neural networks</li>
											<li><strong>Keras Preprocessing</strong> for individual image prediction and testing</li>
										</ul>

										<h4>üß™ <strong>Data Pipeline:</strong></h4>
										<ul>
											<li><strong>Data Preprocessing & Augmentation</strong> Applied comprehensive data augmentation to training set: <code>rescaling</code> <strong>(1./255)</strong>, <code>shear transformation</code> <strong>(0.2)</strong>, <code>zoom</code> <strong>(0.2)</strong>, and horizontal flipping to increase dataset diversity, resized all images to <strong>64x64 pixels</strong> for consistent input dimensions, used <code>ImageDataGenerator</code> to load images directly from directory structure with binary class mode and applied only rescaling to test set to maintain evaluation integrity </li>
											<li><strong>CNN Architechural Design:</strong> Built Sequential CNN with systematic layer progression: <strong>Convolution</strong> ‚Üí <strong>Pooling</strong> ‚Üí <strong>Convolution</strong> ‚Üí <strong>Pooling</strong> ‚Üí <strong>Flatten</strong> ‚Üí <strong>Dense</strong> ‚Üí <strong>Output</strong>, <strong>First convolutional layer:</strong> <code>32 filters</code> with <code>3x3 kernel</code> and <code>ReLU activation</code>, input shape <code>[64, 64, 3]</code>, Added <strong>MaxPool2D layers</strong> <code>(2x2, stride=2)</code> after each convolution for spatial dimension reduction, <strong>Flattened feature</strong> maps before dense layers and added <strong>fully connected layer</strong> <code>(128 units, ReLU)</code>, <strong>Output layer:</strong> Single neuron with <code>sigmoid activation</code> for binary classification </li>
											<li><strong>Model Training & Evaluation:</strong> Compiled with <code>Adam optimizer</code>,  <code>binary crossentropy loss</code>, and accuracy metrics, trained for <strong>25 epochs</strong> using training set with validation on test set and implemented single image prediction pipeline with proper preprocessing and class mapping</li>
											
											
										</ul>

										<h4>üìä <strong>Code Snippets & Visualisations:</strong></h4>

										<!-- Code Snippet -->

										<pre><code class="language-python"># Importing the libraries
										import tensorflow as tf
										from keras.preprocessing.image import ImageDataGenerator

										# Preprocessing Training set
										train_datagen = ImageDataGenerator(rescale = 1./255,
																		shear_range = 0.2,
																		zoom_range = 0.2,
																		horizontal_flip = True)
										training_set = train_datagen.flow_from_directory('dataset/training_set',
																						target_size = (64, 64),
																						batch_size = 32,
																						class_mode = 'binary')

										# Preprocessing Test set
										test_datagen = ImageDataGenerator(rescale = 1./255)
										test_set = test_datagen.flow_from_directory('dataset/test_set',
																					target_size = (64, 64),
																					batch_size = 32,
																					class_mode = 'binary')

										# Building the CNN

										# Initialising CNN
										cnn = tf.keras.models.Sequential()
										# Step 1 - Convolution
										cnn.add(tf.keras.layers.Conv2D(filters=32, kernel_size=3, activation='relu', input_shape=[64, 64, 3]))
										# Step 2 - Pooling
										cnn.add(tf.keras.layers.MaxPool2D(pool_size=2, strides=2))
										# Step 3 - Adding second layer
										cnn.add(tf.keras.layers.Conv2D(filters=32, kernel_size=3, activation='relu'))
										cnn.add(tf.keras.layers.MaxPool2D(pool_size=2, strides=2))
										# Step 4 - Flattening
										cnn.add(tf.keras.layers.Flatten())
										# Step 5 - Full connection
										cnn.add(tf.keras.layers.Dense(units=128, activation='relu'))
										# Step 6 - Flattening
										cnn.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))

										# Compiling CNN
										cnn.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])

										# Training CNN and evaluating on test set
										cnn.fit(x = training_set, validation_data = test_set, epochs = 25)

										# Making a single prediction
										import numpy as np
										from keras.preprocessing import image
										test_image = image.load_img('dataset/single_prediction/cat_or_dog_1.jpg', target_size = (64, 64))
										test_image = image.img_to_array(test_image)
										test_image = np.expand_dims(test_image, axis = 0)
										result = cnn.predict(test_image)
										training_set.class_indices
										if result[0][0] == 1:
										prediction = 'dog'
										else:
										prediction = 'cat'

										print(prediction)
										</code></pre>

										
										<!-- Visualisations -->

										

										<h4>üåü <strong>Key Insights:</strong></h4>
										<p>
											<li>Data augmentation significantly improved model generalization by artificially expanding the training dataset through transformations, helping the CNN learn invariant features regardless of image orientation or lighting conditions</li>
											<li>Two-layer CNN architecture effectively captured hierarchical features from low-level edges and textures in early layers to high-level animal-specific patterns in deeper layers for robust classification</li>
											<li>MaxPooling layers provided crucial dimensionality reduction while preserving important spatial features, enabling the model to focus on the most discriminative regions for cat vs dog classification</li>
										</p>

										<h4>üßóüèæ <strong>Challenge Faced:</strong></h4>
										<p>
											The primary challenge was balancing model complexity with training efficiency given the 64x64 input resolution. Initially, I experimented with deeper architectures but encountered overfitting and slow training times. After testing various configurations, I discovered that two convolutional layers provided sufficient feature extraction capability while maintaining reasonable training speed and preventing overfitting on the limited dataset size.
										</p>
										
									</section>



							</article>

						<!-- About Me -->
							<article id="about">
								<h2 class="major">About Me</h2>
								<span class="image main"><img src="images/bio.jpg" alt="" style="width: 70%; max-width: 550px; margin-left: 90px; border-radius: 4px; " /></span>
								<p>I am an aspiring data scientist and educator focused on curriculum innovation, AI-driven assessment, and machine learning for real-world educational impact. I attained my BSc in Liberal Arts & Sciences from Maastricht University, where I learned to blend critical thinking with interdisciplinary research‚Äîdeveloping a mindset for tackling complex, real-world challenges.</p>
								<p>At the University of Manchester, I took a deep dive into molecular biology research through an MRes in Tissue Engineering for Regenerative Medicine. There, I developed a gene therapy model for a genetic muscle-wasting disease, which acted as a proof-of-principle to support early stage clinical trials. During this time I strengthened my hypothesis-driven probelm solving approach and my ability to leverage data to tell a stories at the intersection of biomedical engineering, and data analysis.</p>
								<p>As a former science coordinator in the UAE public education system, I designed national exams, and later began integrating generative AI tools into the classroom. These experiences sparked my current focus of understanding  data to  help build AI systems that empower with how people learn‚Äîethically, adaptively, and with lasting impact.</p>
							</article>

						<!-- Contact -->
							<article id="contact">
								<h2 class="major">Contact</h2>
								<form method="post" action="https://formspree.io/f/xkgbojve">
									<div class="fields">
										<div class="field half">
											<label for="name">Name</label>
											<input type="text" name="name" id="name" required="" autocomplete="name" />
										</div>
										<div class="field half">
											<label for="email">Email</label>
											<input type="text" name="email" id="email" required="" autocomplete="email"/>
										</div>
										<div class="field">
											<label for="message">Message</label>
											<textarea name="message" id="message" rows="4"></textarea>
										</div>
									</div>
									<!-- Hidden fields for better Formspree functionality -->
									<input type="hidden" name="_subject" value="New contact from Data Science Portfolio" />
									<input type="hidden" name="_next" value="#contact" />

									<ul class="actions">
										<li><input type="submit" value="Send Message" class="primary" /></li>
										<li><input type="reset" value="Reset" /></li>
									</ul>
								</form>
								<ul class="icons">
									<li><a href="https://www.linkedin.com/in/tendai-sibanda" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
									<li><a href="https://github.com/tendai-codes" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
								</ul>
							</article>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<p>&copy; 2025 Tendai Sibanda. All rights reserved.</p>

						<ul class="icons">
							<li><a href="https://www.linkedin.com/in/tendai-sibanda" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
							<li><a href="https://github.com/tendai-codes" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
						</ul>

						<p class="credit" style="font-size: 0.8em; opacity: 0.6;">
							Template design by <a href="https://html5up.net" target="_blank">HTML5 UP</a>
						</p>
					</footer>

			</div>

		<!-- BG -->
			<div id="bg"></div>

			<!-- Gallery Modal -->
			<div id="galleryModal" class="gallery-modal">
				<div class="modal-content">
					<button class="close-btn" onclick="closeGallery()">&times;</button>
					<button class="nav-btn prev-btn" onclick="changeImage(-1)">&#8249;</button>
					<button class="nav-btn next-btn" onclick="changeImage(1)">&#8250;</button>

					<img id="modalImage" class="gallery-image" src="" alt="">
					<div class="image-counter">
						<span id="currentImageNum">1</span> / <span id="totalImages">1</span>
					</div>
					<div id="modalCaption" style="color: white; text-align: center; margin-top: 10px;"></div>
					<div class="thumbnail-strip" id="thumbnailStrip"></div>
				</div>
			</div>

			<!-- Highlight.js core script -->
			<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
			<!-- Optional: Load specific languages -->
				<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
			<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/r.min.js"></script>

			<!-- Initialise Highlight.js -->
			<script>hljs.highlightAll();</script>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

			<script>
			
			let currentGallery = [];
			let currentImageIndex = 0;
			let currentProjectSection = null;
			let scrollPosition = 0;
			let galleryOpen = false;
			let targetScrollPosition = 0;

			// Initialize gallery functionality
			document.addEventListener('DOMContentLoaded', function() {
				// Add click listeners to all gallery trigger images
				document.querySelectorAll('.gallery-trigger').forEach(img => {
					img.addEventListener('click', function() {
						openGallery(this);
					});
				});

				// Keyboard navigation
				document.addEventListener('keydown', function(e) {
					if (galleryOpen) {
						if (e.key === 'ArrowLeft') changeImage(-1);
						if (e.key === 'ArrowRight') changeImage(1);
						if (e.key === 'Escape') closeGallery();
					}
				});

				// Close modal when clicking outside image
				document.getElementById('galleryModal').addEventListener('click', function(e) {
					if (e.target === this) {
						closeGallery();
					}
				});

				// Override the main.js scroll behavior when gallery is involved
				const originalScrollTop = $.fn.scrollTop;
				$.fn.scrollTop = function(value) {
					// If gallery just closed, don't let main.js scroll to top
					if (arguments.length && value === 0 && galleryOpen === 'closing') {
						console.log('Prevented main.js from scrolling to top');
						return this;
					}
					return originalScrollTop.apply(this, arguments);
				};
			});

			function openGallery(clickedImage) {
				galleryOpen = true;
				
				// Store current scroll position and find project section
				scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
				
				currentProjectSection = clickedImage.closest('.project-item') || 
									clickedImage.closest('.project') || 
									clickedImage.closest('section') ||
									clickedImage.closest('article');
				
				console.log('Opening gallery, scroll position:', scrollPosition);
				console.log('Project section found:', currentProjectSection);
				
				const galleryName = clickedImage.getAttribute('data-gallery') || 'default';
				currentGallery = Array.from(document.querySelectorAll(`img.gallery-trigger[data-gallery="${galleryName}"]`));
				currentImageIndex = currentGallery.indexOf(clickedImage);
				
				// Show modal
				document.getElementById('galleryModal').style.display = 'block';
				document.body.style.overflow = 'hidden';
				
				displayCurrentImage();
				createThumbnails();
			}

			function closeGallery() {
				galleryOpen = 'closing'; // Special state to prevent scroll interference
				
				document.getElementById('galleryModal').style.display = 'none';
				document.body.style.overflow = 'auto';

				console.log('Closing gallery, will restore to position:', scrollPosition);
				
				// Calculate target position if we have a project section
				if (currentProjectSection) {
					const rect = currentProjectSection.getBoundingClientRect();
					targetScrollPosition = rect.top + window.pageYOffset - 50;
					console.log('Target scroll position for project:', targetScrollPosition);
				} else {
					targetScrollPosition = scrollPosition;
				}
				
				// Use multiple approaches to restore position
				
				// Immediate attempt
				setTimeout(() => {
					window.scrollTo({
						top: targetScrollPosition,
						behavior: 'instant'
					});
					console.log('First scroll attempt to:', targetScrollPosition);
				}, 10);
				
				// Second attempt after potential main.js interference
				setTimeout(() => {
					window.scrollTo({
						top: targetScrollPosition,
						behavior: 'instant'
					});
					console.log('Second scroll attempt to:', targetScrollPosition);
				}, 100);
				
				// Final attempt with smooth scroll
				setTimeout(() => {
					if (Math.abs(window.pageYOffset - targetScrollPosition) > 50) {
						window.scrollTo({
							top: targetScrollPosition,
							behavior: 'smooth'
						});
						console.log('Final smooth scroll to:', targetScrollPosition);
					}
					galleryOpen = false; // Reset state after all attempts
				}, 300);
			}

			function changeImage(direction) {
				currentImageIndex += direction;
				
				if (currentImageIndex >= currentGallery.length) {
					currentImageIndex = 0;
				} else if (currentImageIndex < 0) {
					currentImageIndex = currentGallery.length - 1;
				}
				
				displayCurrentImage();
				updateThumbnails();
			}

			function displayCurrentImage() {
				const currentImg = currentGallery[currentImageIndex];
				const modalImage = document.getElementById('modalImage');
				
				modalImage.src = currentImg.src;
				modalImage.alt = currentImg.getAttribute('data-caption') || currentImg.alt;
				
				document.getElementById('currentImageNum').textContent = currentImageIndex + 1;
				document.getElementById('totalImages').textContent = currentGallery.length;
			}

			function createThumbnails() {
				const thumbnailStrip = document.getElementById('thumbnailStrip');
				thumbnailStrip.innerHTML = '';
				
				currentGallery.forEach((img, index) => {
					const thumbnail = document.createElement('img');
					thumbnail.src = img.src;
					thumbnail.className = 'thumbnail';
					thumbnail.addEventListener('click', () => {
						currentImageIndex = index;
						displayCurrentImage();
						updateThumbnails();
					});
					
					thumbnailStrip.appendChild(thumbnail);
				});
				
				updateThumbnails();
			}

			function updateThumbnails() {
				const thumbnails = document.querySelectorAll('.thumbnail');
				thumbnails.forEach((thumb, index) => {
					thumb.classList.toggle('active', index === currentImageIndex);
				});
			}

			</script>

			<script>
				document.addEventListener("DOMContentLoaded", () => {
					const buttons = document.querySelectorAll(".filter-button");
					const projects = document.querySelectorAll(".project-item");

					//  Hide all projects by default
					projects.forEach(project => {
						project.style.display = "none";
					});

					// Add event listener to all buttons
					buttons.forEach(button => {
						button.addEventListener("click", () => {
							// Get selected tag from button
							const tag = button.getAttribute("data-tag");
							activeTag = tag;

							// Highlight the active button
							buttons.forEach(btn => btn.classList.remove("active"));
							button.classList.add("active");

							// Filter projects
							projects.forEach(project => {
								const tags = project.getAttribute("data-tags").split(",").map(tag => tag.trim());
								if (tag === "all" || tags.includes(tag)) {
									project.style.display = "block";
								} else {
									project.style.display = "none";
								}
							});
						});
					});
				});
				
			</script>

	</body>
</html>
